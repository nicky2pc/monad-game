import "./chunk-42B64YFO.js";
import "./chunk-53FRD565.js";
import "./chunk-7MHL6MFZ.js";
import "./chunk-OOKXOQJ2.js";
import "./chunk-SLVPW4W2.js";
import "./chunk-6QOWD2HI.js";
import "./chunk-V3HVOFPL.js";
import {
  ProviderUtil
} from "./chunk-MQX7JNME.js";
import "./chunk-FS3CSUOV.js";
import "./chunk-CR5QDPRG.js";
import "./chunk-HCKM3YCZ.js";
import "./chunk-FSEHWOMA.js";
import "./chunk-6WNHIMDK.js";
import "./chunk-FDHB5X2Y.js";
import {
  ifDefined,
  state
} from "./chunk-FFEBZBNZ.js";
import {
  AccountController,
  ChainController,
  ConnectionController,
  ConstantsUtil,
  ContractUtil,
  CoreHelperUtil,
  ModalController,
  OptionsController,
  ParseUtil,
  RouterController,
  SnackController,
  ThemeController,
  customElement,
  proxy,
  subscribe,
  subscribeKey
} from "./chunk-QCN5WM3V.js";
import "./chunk-7ROJEQYY.js";
import "./chunk-X62NSIHN.js";
import "./chunk-SP76EASD.js";
import {
  LitElement,
  css,
  html
} from "./chunk-DWURULDA.js";
import "./chunk-6JRJMGLU.js";
import "./chunk-TNAMY4JT.js";
import "./chunk-O5RFQHER.js";
import "./chunk-TJXQ3TKJ.js";
import "./chunk-FJXQD5XT.js";
import "./chunk-OS7ZSSJM.js";

// node_modules/@reown/appkit-pay/dist/esm/src/types/errors.js
var AppKitPayErrorCodes = {
  INVALID_PAYMENT_CONFIG: "INVALID_PAYMENT_CONFIG",
  INVALID_RECIPIENT: "INVALID_RECIPIENT",
  INVALID_ASSET: "INVALID_ASSET",
  INVALID_AMOUNT: "INVALID_AMOUNT",
  UNKNOWN_ERROR: "UNKNOWN_ERROR",
  UNABLE_TO_INITIATE_PAYMENT: "UNABLE_TO_INITIATE_PAYMENT",
  INVALID_CHAIN_NAMESPACE: "INVALID_CHAIN_NAMESPACE",
  GENERIC_PAYMENT_ERROR: "GENERIC_PAYMENT_ERROR",
  UNABLE_TO_GET_EXCHANGES: "UNABLE_TO_GET_EXCHANGES",
  ASSET_NOT_SUPPORTED: "ASSET_NOT_SUPPORTED",
  UNABLE_TO_GET_PAY_URL: "UNABLE_TO_GET_PAY_URL",
  UNABLE_TO_GET_BUY_STATUS: "UNABLE_TO_GET_BUY_STATUS"
};
var AppKitPayErrorMessages = {
  [AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG]: "Invalid payment configuration",
  [AppKitPayErrorCodes.INVALID_RECIPIENT]: "Invalid recipient address",
  [AppKitPayErrorCodes.INVALID_ASSET]: "Invalid asset specified",
  [AppKitPayErrorCodes.INVALID_AMOUNT]: "Invalid payment amount",
  [AppKitPayErrorCodes.UNKNOWN_ERROR]: "Unknown payment error occurred",
  [AppKitPayErrorCodes.UNABLE_TO_INITIATE_PAYMENT]: "Unable to initiate payment",
  [AppKitPayErrorCodes.INVALID_CHAIN_NAMESPACE]: "Invalid chain namespace",
  [AppKitPayErrorCodes.GENERIC_PAYMENT_ERROR]: "Unable to process payment",
  [AppKitPayErrorCodes.UNABLE_TO_GET_EXCHANGES]: "Unable to get exchanges",
  [AppKitPayErrorCodes.ASSET_NOT_SUPPORTED]: "Asset not supported by the selected exchange",
  [AppKitPayErrorCodes.UNABLE_TO_GET_PAY_URL]: "Unable to get payment URL",
  [AppKitPayErrorCodes.UNABLE_TO_GET_BUY_STATUS]: "Unable to get buy status"
};
var AppKitPayError = class _AppKitPayError extends Error {
  get message() {
    return AppKitPayErrorMessages[this.code];
  }
  constructor(code, details) {
    super(AppKitPayErrorMessages[code]);
    this.name = "AppKitPayError";
    this.code = code;
    this.details = details;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _AppKitPayError);
    }
  }
};

// node_modules/@reown/appkit-pay/dist/esm/src/utils/ConstantsUtil.js
var API_URL = "https://rpc.walletconnect.org/v1/json-rpc";

// node_modules/@reown/appkit-pay/dist/esm/src/utils/ApiUtil.js
var JsonRpcError = class extends Error {
};
function getApiUrl() {
  const projectId = OptionsController.getSnapshot().projectId;
  return `${API_URL}?projectId=${projectId}`;
}
async function sendRequest(method, params) {
  const url = getApiUrl();
  const requestBody = {
    jsonrpc: "2.0",
    id: 1,
    method,
    params
  };
  const response = await fetch(url, {
    method: "POST",
    body: JSON.stringify(requestBody),
    headers: { "Content-Type": "application/json" }
  });
  const json = await response.json();
  if (json.error) {
    throw new JsonRpcError(json.error.message);
  }
  return json;
}
async function getExchanges(params) {
  const response = await sendRequest("reown_getExchanges", params);
  return response.result;
}
async function getPayUrl(params) {
  const response = await sendRequest("reown_getExchangePayUrl", params);
  return response.result;
}
async function getBuyStatus(params) {
  const response = await sendRequest("reown_getExchangeBuyStatus", params);
  return response.result;
}

// node_modules/@reown/appkit-pay/dist/esm/src/utils/AssetUtil.js
var CHAIN_ASSET_INFO_MAP = {
  eip155: {
    native: { assetNamespace: "slip44", assetReference: "60" },
    defaultTokenNamespace: "erc20"
  }
};
function formatCaip19Asset(caipNetworkId, asset) {
  const { chainNamespace, chainId } = ParseUtil.parseCaipNetworkId(caipNetworkId);
  const chainInfo = CHAIN_ASSET_INFO_MAP[chainNamespace];
  if (!chainInfo) {
    throw new Error(`Unsupported chain namespace for CAIP-19 formatting: ${chainNamespace}`);
  }
  let assetNamespace = chainInfo.native.assetNamespace;
  let assetReference = chainInfo.native.assetReference;
  if (asset !== "native") {
    assetNamespace = chainInfo.defaultTokenNamespace;
    assetReference = asset;
  }
  const networkPart = `${chainNamespace}:${chainId}`;
  return `${networkPart}/${assetNamespace}:${assetReference}`;
}

// node_modules/@reown/appkit-pay/dist/esm/src/utils/PaymentUtil.js
async function ensureCorrectNetwork(options) {
  const { paymentAssetNetwork, activeCaipNetwork, approvedCaipNetworkIds, requestedCaipNetworks } = options;
  const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
  const assetCaipNetwork = sortedNetworks.find((network) => network.caipNetworkId === paymentAssetNetwork);
  if (!assetCaipNetwork) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG);
  }
  if (assetCaipNetwork.caipNetworkId === activeCaipNetwork.caipNetworkId) {
    return;
  }
  const isSupportingAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", assetCaipNetwork.chainNamespace);
  const isSwitchAllowed = (approvedCaipNetworkIds == null ? void 0 : approvedCaipNetworkIds.includes(assetCaipNetwork.caipNetworkId)) || isSupportingAllNetworks;
  if (!isSwitchAllowed) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG);
  }
  try {
    await ChainController.switchActiveNetwork(assetCaipNetwork);
  } catch (error) {
    throw new AppKitPayError(AppKitPayErrorCodes.GENERIC_PAYMENT_ERROR, error);
  }
}
async function processEvmNativePayment(paymentAsset, chainNamespace, fromAddress) {
  var _a;
  if (chainNamespace !== ConstantsUtil.CHAIN.EVM) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_CHAIN_NAMESPACE);
  }
  const amountValue = typeof paymentAsset.amount === "string" ? parseFloat(paymentAsset.amount) : paymentAsset.amount;
  if (isNaN(amountValue)) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG);
  }
  const decimals = ((_a = paymentAsset.metadata) == null ? void 0 : _a.decimals) ?? 18;
  const amountBigInt = ConnectionController.parseUnits(amountValue.toString(), decimals);
  if (typeof amountBigInt !== "bigint") {
    throw new AppKitPayError(AppKitPayErrorCodes.GENERIC_PAYMENT_ERROR);
  }
  if (chainNamespace !== ConstantsUtil.CHAIN.EVM) {
    throw new AppKitPayError(AppKitPayErrorCodes.INVALID_CHAIN_NAMESPACE);
  }
  const txResponse = await ConnectionController.sendTransaction({
    chainNamespace,
    to: paymentAsset.recipient,
    address: fromAddress,
    value: amountBigInt,
    data: "0x"
  });
  return txResponse ?? void 0;
}
async function processEvmErc20Payment(paymentAsset, fromAddress) {
  const tokenAddress = paymentAsset.asset;
  const recipientAddress = paymentAsset.recipient;
  const decimals = Number(paymentAsset.metadata.decimals);
  const amount = ConnectionController.parseUnits(paymentAsset.amount.toString(), decimals);
  if (amount === void 0) {
    throw new AppKitPayError(AppKitPayErrorCodes.GENERIC_PAYMENT_ERROR);
  }
  const txResponse = await ConnectionController.writeContract({
    fromAddress,
    tokenAddress,
    args: [recipientAddress, amount],
    method: "transfer",
    abi: ContractUtil.getERC20Abi(tokenAddress),
    chainNamespace: ConstantsUtil.CHAIN.EVM
  });
  return txResponse ?? void 0;
}

// node_modules/@reown/appkit-pay/dist/esm/src/controllers/PayController.js
var DEFAULT_PAGE = 0;
var state2 = proxy({
  paymentAsset: {
    network: "eip155:1",
    recipient: "0x0",
    asset: "0x0",
    amount: 0,
    metadata: {
      name: "0x0",
      symbol: "0x0",
      decimals: 0
    }
  },
  isConfigured: false,
  error: null,
  isPaymentInProgress: false,
  exchanges: [],
  isLoading: false,
  openInNewTab: true,
  redirectUrl: void 0,
  payWithExchange: void 0,
  currentPayment: void 0
});
var PayController = {
  state: state2,
  subscribe(callback) {
    return subscribe(state2, () => callback(state2));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state2, key, callback);
  },
  async handleOpenPay(options) {
    this.resetState();
    this.setPaymentConfig(options);
    this.subscribeEvents();
    state2.isConfigured = true;
    await ModalController.open({
      view: "Pay"
    });
  },
  resetState() {
    state2.paymentAsset = {
      network: "eip155:1",
      recipient: "0x0",
      asset: "0x0",
      amount: 0,
      metadata: { name: "0x0", symbol: "0x0", decimals: 0 }
    };
    state2.isConfigured = false;
    state2.error = null;
    state2.isPaymentInProgress = false;
    state2.isLoading = false;
    state2.currentPayment = void 0;
  },
  setPaymentConfig(config) {
    if (!config.paymentAsset) {
      throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG);
    }
    try {
      state2.paymentAsset = config.paymentAsset;
      state2.openInNewTab = config.openInNewTab ?? true;
      state2.redirectUrl = config.redirectUrl;
      state2.payWithExchange = config.payWithExchange;
      state2.error = null;
    } catch (error) {
      throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG, error.message);
    }
  },
  getPaymentAsset() {
    return state2.paymentAsset;
  },
  getExchanges() {
    return state2.exchanges;
  },
  async fetchExchanges() {
    try {
      state2.isLoading = true;
      const response = await getExchanges({
        page: DEFAULT_PAGE
      });
      state2.exchanges = response.exchanges.slice(0, 2);
    } catch (error) {
      SnackController.showError(AppKitPayErrorMessages.UNABLE_TO_GET_EXCHANGES);
      throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_GET_EXCHANGES);
    } finally {
      state2.isLoading = false;
    }
  },
  async getAvailableExchanges(page = DEFAULT_PAGE) {
    try {
      const response = await getExchanges({
        page
      });
      return response;
    } catch (error) {
      throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_GET_EXCHANGES);
    }
  },
  async getPayUrl(exchangeId, params) {
    try {
      const numericAmount = Number(params.amount);
      const response = await getPayUrl({
        exchangeId,
        asset: formatCaip19Asset(params.network, params.asset),
        amount: numericAmount.toString(16),
        recipient: `${params.network}:${params.recipient}`
      });
      return response;
    } catch (error) {
      if (error instanceof Error && error.message.includes("is not supported")) {
        throw new AppKitPayError(AppKitPayErrorCodes.ASSET_NOT_SUPPORTED);
      }
      throw new Error(error.message);
    }
  },
  async openPayUrl(exchangeId, params, openInNewTab = true) {
    try {
      const payUrl = await this.getPayUrl(exchangeId, params);
      if (!payUrl) {
        throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_GET_PAY_URL);
      }
      const target = openInNewTab ? "_blank" : "_self";
      CoreHelperUtil.openHref(payUrl.url, target);
      return payUrl;
    } catch (error) {
      if (error instanceof AppKitPayError) {
        state2.error = error.message;
      } else {
        state2.error = AppKitPayErrorMessages.GENERIC_PAYMENT_ERROR;
      }
      throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_GET_PAY_URL);
    }
  },
  subscribeEvents() {
    if (state2.isConfigured) {
      return;
    }
    ProviderUtil.subscribeProviders(async (_) => {
      const chainNamespace = ChainController.state.activeChain;
      const provider = ProviderUtil.getProvider(chainNamespace);
      if (!provider) {
        return;
      }
      await this.handlePayment();
    });
    AccountController.subscribeKey("caipAddress", async (caipAddress) => {
      if (!caipAddress) {
        return;
      }
      await this.handlePayment();
    });
  },
  async handlePayment() {
    state2.currentPayment = {
      type: "wallet"
    };
    const caipAddress = AccountController.state.caipAddress;
    if (!caipAddress) {
      return;
    }
    const { chainId, address } = ParseUtil.parseCaipAddress(caipAddress);
    const chainNamespace = ChainController.state.activeChain;
    if (!address || !chainId || !chainNamespace) {
      return;
    }
    const provider = ProviderUtil.getProvider(chainNamespace);
    if (!provider) {
      return;
    }
    const caipNetwork = ChainController.state.activeCaipNetwork;
    if (!caipNetwork) {
      return;
    }
    if (state2.isPaymentInProgress) {
      return;
    }
    try {
      state2.isPaymentInProgress = true;
      const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
      const approvedCaipNetworkIds = ChainController.getAllApprovedCaipNetworkIds();
      await ensureCorrectNetwork({
        paymentAssetNetwork: state2.paymentAsset.network,
        activeCaipNetwork: caipNetwork,
        approvedCaipNetworkIds,
        requestedCaipNetworks
      });
      await ModalController.open({
        view: "PayLoading"
      });
      switch (chainNamespace) {
        case ConstantsUtil.CHAIN.EVM:
          if (state2.paymentAsset.asset === "native") {
            state2.currentPayment.result = await processEvmNativePayment(state2.paymentAsset, chainNamespace, address);
          }
          if (state2.paymentAsset.asset.startsWith("0x")) {
            state2.currentPayment.result = await processEvmErc20Payment(state2.paymentAsset, address);
          }
          break;
        default:
          throw new AppKitPayError(AppKitPayErrorCodes.INVALID_CHAIN_NAMESPACE);
      }
    } catch (error) {
      if (error instanceof AppKitPayError) {
        state2.error = error.message;
      } else {
        state2.error = AppKitPayErrorMessages.GENERIC_PAYMENT_ERROR;
      }
      SnackController.showError(state2.error);
    } finally {
      state2.isPaymentInProgress = false;
    }
  },
  getExchangeById(exchangeId) {
    return state2.exchanges.find((exchange) => exchange.id === exchangeId);
  },
  validatePayConfig(config) {
    const { paymentAsset } = config;
    if (!paymentAsset) {
      throw new AppKitPayError(AppKitPayErrorCodes.INVALID_PAYMENT_CONFIG);
    }
    if (!paymentAsset.recipient) {
      throw new AppKitPayError(AppKitPayErrorCodes.INVALID_RECIPIENT);
    }
    if (!paymentAsset.asset) {
      throw new AppKitPayError(AppKitPayErrorCodes.INVALID_ASSET);
    }
    if (!paymentAsset.amount) {
      throw new AppKitPayError(AppKitPayErrorCodes.INVALID_AMOUNT);
    }
  },
  handlePayWithWallet() {
    const caipAddress = AccountController.state.caipAddress;
    if (!caipAddress) {
      RouterController.push("Connect");
      return;
    }
    const { chainId, address } = ParseUtil.parseCaipAddress(caipAddress);
    const chainNamespace = ChainController.state.activeChain;
    if (!address || !chainId || !chainNamespace) {
      RouterController.push("Connect");
      return;
    }
    this.handlePayment();
  },
  async handlePayWithExchange(exchangeId) {
    try {
      state2.currentPayment = {
        type: "exchange",
        exchangeId
      };
      state2.isPaymentInProgress = true;
      const { network, asset, amount, recipient } = state2.paymentAsset;
      const payUrlParams = { network, asset, amount, recipient };
      const payUrl = await this.getPayUrl(exchangeId, payUrlParams);
      if (!payUrl) {
        throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_INITIATE_PAYMENT);
      }
      state2.currentPayment.sessionId = payUrl.sessionId;
      state2.currentPayment.status = "IN_PROGRESS";
      state2.currentPayment.exchangeId = exchangeId;
      return {
        url: payUrl.url,
        openInNewTab: state2.openInNewTab
      };
    } catch (error) {
      if (error instanceof AppKitPayError) {
        state2.error = error.message;
      } else {
        state2.error = AppKitPayErrorMessages.GENERIC_PAYMENT_ERROR;
      }
      state2.isPaymentInProgress = false;
      SnackController.showError(state2.error);
      return null;
    }
  },
  async getBuyStatus(exchangeId, sessionId) {
    try {
      const status = await getBuyStatus({ sessionId, exchangeId });
      return status;
    } catch (error) {
      throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_GET_BUY_STATUS);
    }
  },
  async updateBuyStatus(exchangeId, sessionId) {
    try {
      const status = await this.getBuyStatus(exchangeId, sessionId);
      if (state2.currentPayment) {
        state2.currentPayment.status = status.status;
        state2.currentPayment.result = status.txHash;
      }
      if (status.status === "SUCCESS" || status.status === "FAILED") {
        state2.isPaymentInProgress = false;
      }
    } catch (error) {
      throw new AppKitPayError(AppKitPayErrorCodes.UNABLE_TO_GET_BUY_STATUS);
    }
  }
};

// node_modules/@reown/appkit-pay/dist/esm/src/ui/w3m-pay-view/styles.js
var styles_default = css`
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-xs)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }

  .token-display {
    padding: var(--wui-spacing-s) var(--wui-spacing-m);
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-color-bg-125);
    margin-top: var(--wui-spacing-s);
    margin-bottom: var(--wui-spacing-s);
  }

  .token-display wui-text {
    text-transform: none;
  }

  wui-loading-spinner {
    padding: var(--wui-spacing-xs);
  }
`;

// node_modules/@reown/appkit-pay/dist/esm/src/ui/w3m-pay-view/index.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var W3mPayView = class W3mPayView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.amount = "";
    this.tokenSymbol = "";
    this.networkName = "";
    this.exchanges = PayController.state.exchanges;
    this.isLoading = PayController.state.isLoading;
    this.loadingExchangeId = null;
    this.connectedWalletInfo = AccountController.state.connectedWalletInfo;
    this.initializePaymentDetails();
    this.unsubscribe.push(PayController.subscribeKey("exchanges", (val) => this.exchanges = val));
    this.unsubscribe.push(PayController.subscribeKey("isLoading", (val) => this.isLoading = val));
    this.unsubscribe.push(AccountController.subscribe((newState) => this.connectedWalletInfo = newState.connectedWalletInfo));
    PayController.fetchExchanges();
  }
  get isWalletConnected() {
    return AccountController.state.status === "connected";
  }
  render() {
    return html`
      <wui-flex flexDirection="column">
        <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]} gap="s">
          ${this.renderPaymentHeader()}

          <wui-flex flexDirection="column" gap="s">
            <wui-flex flexDirection="column" gap="s">
              ${this.isWalletConnected ? this.renderConnectedView() : this.renderDisconnectedView()}
            </wui-flex>
            <wui-separator text="or"></wui-separator>
            ${this.renderExchangeOptions()}
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  initializePaymentDetails() {
    const paymentAsset = PayController.getPaymentAsset();
    this.networkName = paymentAsset.network;
    this.tokenSymbol = paymentAsset.metadata.symbol;
    this.amount = paymentAsset.amount.toString();
  }
  renderPaymentHeader() {
    let displayNetworkName = this.networkName;
    if (this.networkName) {
      const allNetworks = ChainController.getAllRequestedCaipNetworks();
      const targetNetwork = allNetworks.find((net) => net.caipNetworkId === this.networkName);
      if (targetNetwork) {
        displayNetworkName = targetNetwork.name;
      }
    }
    return html`
      <wui-flex flexDirection="column" alignItems="center">
        <wui-flex alignItems="center" gap="xs">
          <wui-text variant="large-700" color="fg-100">${this.amount || "0.0000"}</wui-text>
          <wui-flex class="token-display" alignItems="center" gap="xxs">
            <wui-text variant="paragraph-600" color="fg-100">
              ${this.tokenSymbol || "Unknown Asset"}
            </wui-text>
            ${displayNetworkName ? html`
                  <wui-text variant="small-500" color="fg-200"> on ${displayNetworkName} </wui-text>
                ` : ""}
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  renderConnectedView() {
    var _a, _b, _c;
    const walletName = ((_a = this.connectedWalletInfo) == null ? void 0 : _a.name) || "connected wallet";
    return html`
      <wui-list-item
        @click=${this.onWalletPayment}
        ?chevron=${true}
        data-testid="wallet-payment-option"
      >
        <wui-flex alignItems="center" gap="s">
          <wui-wallet-image
            size="sm"
            imageSrc=${ifDefined((_b = this.connectedWalletInfo) == null ? void 0 : _b.icon)}
            name=${ifDefined((_c = this.connectedWalletInfo) == null ? void 0 : _c.name)}
          ></wui-wallet-image>
          <wui-text variant="paragraph-500" color="inherit">Pay with ${walletName}</wui-text>
        </wui-flex>
      </wui-list-item>

      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="disconnect"
        @click=${this.onDisconnect}
        data-testid="disconnect-button"
        ?chevron=${false}
      >
        <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
      </wui-list-item>
    `;
  }
  renderDisconnectedView() {
    return html`<wui-list-item
      variant="icon"
      iconVariant="overlay"
      icon="walletPlaceholder"
      @click=${this.onWalletPayment}
      ?chevron=${true}
      data-testid="wallet-payment-option"
    >
      <wui-text variant="paragraph-500" color="inherit">Pay from wallet</wui-text>
    </wui-list-item>`;
  }
  renderExchangeOptions() {
    if (this.isLoading) {
      return html`<wui-flex justifyContent="center" alignItems="center">
        <wui-spinner size="md"></wui-spinner>
      </wui-flex>`;
    }
    if (this.exchanges.length === 0) {
      return html`<wui-flex justifyContent="center" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-100">No exchanges available</wui-text>
      </wui-flex>`;
    }
    return this.exchanges.map((exchange) => html`
        <wui-list-item
          @click=${() => this.onExchangePayment(exchange.id)}
          data-testid="exchange-option-${exchange.id}"
          ?chevron=${true}
          ?disabled=${this.loadingExchangeId !== null}
        >
          <wui-flex alignItems="center" gap="s">
            ${this.loadingExchangeId === exchange.id ? html`<wui-loading-spinner color="accent-100" size="md"></wui-loading-spinner>` : html`<wui-wallet-image
                  size="sm"
                  imageSrc=${ifDefined(exchange.imageUrl)}
                  name=${exchange.name}
                ></wui-wallet-image>`}
            <wui-text flexGrow="1" variant="paragraph-500" color="inherit"
              >Pay with ${exchange.name} <wui-spinner size="sm" color="fg-200"></wui-spinner
            ></wui-text>
          </wui-flex>
        </wui-list-item>
      `);
  }
  onWalletPayment() {
    PayController.handlePayWithWallet();
  }
  async onExchangePayment(exchangeId) {
    try {
      this.loadingExchangeId = exchangeId;
      const result = await PayController.handlePayWithExchange(exchangeId);
      if (result) {
        await ModalController.open({
          view: "PayLoading"
        });
        CoreHelperUtil.openHref(result.url, result.openInNewTab ? "_blank" : "_self");
      }
    } catch (error) {
      console.error("Failed to pay with exchange", error);
      SnackController.showError("Failed to pay with exchange");
    } finally {
      this.loadingExchangeId = null;
    }
  }
  async onDisconnect(e) {
    e.stopPropagation();
    try {
      await ConnectionController.disconnect();
      ModalController.close();
    } catch {
      console.error("Failed to disconnect");
      SnackController.showError("Failed to disconnect");
    }
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
};
W3mPayView.styles = styles_default;
__decorate([
  state()
], W3mPayView.prototype, "amount", void 0);
__decorate([
  state()
], W3mPayView.prototype, "tokenSymbol", void 0);
__decorate([
  state()
], W3mPayView.prototype, "networkName", void 0);
__decorate([
  state()
], W3mPayView.prototype, "exchanges", void 0);
__decorate([
  state()
], W3mPayView.prototype, "isLoading", void 0);
__decorate([
  state()
], W3mPayView.prototype, "loadingExchangeId", void 0);
__decorate([
  state()
], W3mPayView.prototype, "connectedWalletInfo", void 0);
W3mPayView = __decorate([
  customElement("w3m-pay-view")
], W3mPayView);

// node_modules/@reown/appkit-pay/dist/esm/src/ui/w3m-pay-loading-view/styles.js
var styles_default2 = css`
  :host {
    display: block;
    height: 100%;
    width: 100%;
  }
`;

// node_modules/@reown/appkit-pay/dist/esm/src/ui/w3m-pay-loading-view/index.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EXCHANGE_STATUS_CHECK_INTERVAL = 4e3;
var W3mPayLoadingView = class W3mPayLoadingView2 extends LitElement {
  constructor() {
    super();
    this.loadingMessage = "";
    this.subMessage = "";
    this.paymentState = "in-progress";
    this.paymentState = PayController.state.isPaymentInProgress ? "in-progress" : "completed";
    this.updateMessages();
    this.setupSubscription();
    this.setupExchangeSubscription();
  }
  disconnectedCallback() {
    clearInterval(this.exchangeSubscription);
  }
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center"> ${this.getStateIcon()} </wui-flex>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">
            ${this.loadingMessage}
          </wui-text>
          <wui-text align="center" variant="small-400" color="fg-200">
            ${this.subMessage}
          </wui-text>
        </wui-flex>
      </wui-flex>
    `;
  }
  updateMessages() {
    var _a;
    switch (this.paymentState) {
      case "completed":
        this.loadingMessage = "Payment completed";
        this.subMessage = "Your transaction has been successfully processed";
        break;
      case "error":
        this.loadingMessage = "Payment failed";
        this.subMessage = "There was an error processing your transaction";
        break;
      case "in-progress":
      default:
        if (((_a = PayController.state.currentPayment) == null ? void 0 : _a.type) === "exchange") {
          this.loadingMessage = "Payment initiated";
          this.subMessage = `Please complete the payment on the exchange`;
        } else {
          this.loadingMessage = "Awaiting payment confirmation";
          this.subMessage = "Please confirm the payment transaction in your wallet";
        }
        break;
    }
  }
  getStateIcon() {
    switch (this.paymentState) {
      case "completed":
        return this.successTemplate();
      case "error":
        return this.errorTemplate();
      case "in-progress":
      default:
        return this.loaderTemplate();
    }
  }
  setupExchangeSubscription() {
    var _a;
    if (((_a = PayController.state.currentPayment) == null ? void 0 : _a.type) !== "exchange") {
      return;
    }
    this.exchangeSubscription = setInterval(async () => {
      var _a2, _b, _c;
      const exchangeId = (_a2 = PayController.state.currentPayment) == null ? void 0 : _a2.exchangeId;
      const sessionId = (_b = PayController.state.currentPayment) == null ? void 0 : _b.sessionId;
      if (exchangeId && sessionId) {
        await PayController.updateBuyStatus(exchangeId, sessionId);
        if (((_c = PayController.state.currentPayment) == null ? void 0 : _c.status) === "SUCCESS") {
          clearInterval(this.exchangeSubscription);
        }
      }
    }, EXCHANGE_STATUS_CHECK_INTERVAL);
  }
  setupSubscription() {
    PayController.subscribeKey("isPaymentInProgress", (inProgress) => {
      var _a;
      if (!inProgress && this.paymentState === "in-progress") {
        if (PayController.state.error || !((_a = PayController.state.currentPayment) == null ? void 0 : _a.result)) {
          this.paymentState = "error";
        } else {
          this.paymentState = "completed";
        }
        this.updateMessages();
        setTimeout(() => {
          if (ConnectionController.state.status === "disconnected") {
            return;
          }
          ModalController.close();
        }, 3e3);
      }
    });
    PayController.subscribeKey("error", (error) => {
      if (error && this.paymentState === "in-progress") {
        this.paymentState = "error";
        this.updateMessages();
      }
    });
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return html`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  successTemplate() {
    return html`<wui-icon size="xl" color="success-100" name="checkmark"></wui-icon>`;
  }
  errorTemplate() {
    return html`<wui-icon size="xl" color="error-100" name="close"></wui-icon>`;
  }
};
W3mPayLoadingView.styles = styles_default2;
__decorate2([
  state()
], W3mPayLoadingView.prototype, "loadingMessage", void 0);
__decorate2([
  state()
], W3mPayLoadingView.prototype, "subMessage", void 0);
__decorate2([
  state()
], W3mPayLoadingView.prototype, "paymentState", void 0);
W3mPayLoadingView = __decorate2([
  customElement("w3m-pay-loading-view")
], W3mPayLoadingView);

// node_modules/@reown/appkit-pay/dist/esm/src/client.js
async function openPay(options) {
  return PayController.handleOpenPay(options);
}
function getExchanges2() {
  return PayController.getExchanges();
}
function getPayResult() {
  var _a;
  return (_a = PayController.state.currentPayment) == null ? void 0 : _a.result;
}
function getPayError() {
  return PayController.state.error;
}
function getIsPaymentInProgress() {
  return PayController.state.isPaymentInProgress;
}
export {
  W3mPayLoadingView,
  W3mPayView,
  getExchanges2 as getExchanges,
  getIsPaymentInProgress,
  getPayError,
  getPayResult,
  openPay
};
//# sourceMappingURL=exports-NMQNRCRO.js.map
