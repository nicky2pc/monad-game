import { W as Wallet, j as SolanaStandardWallet, k as SolanaFundingConfig, e as SupportedSolanaTransaction, h as SendTransactionModalUIOptions, S as SolanaTransactionReceipt, i as SignMessageModalUIOptions } from './types-B2cNjPPJ.js';
export { C as ConnectedSolanaWallet, l as SolanaAdapterConnector, t as toSolanaWalletConnectors } from './types-B2cNjPPJ.js';
import { P as PrivyEvents } from './useSolanaWallets-CJ5Sl9Y-.js';
export { U as UseSolanaWalletsInterface, u as useSolanaWallets } from './useSolanaWallets-CJ5Sl9Y-.js';
import { SolanaSignAndSendTransactionFeature, SolanaSignTransactionFeature, SolanaSignMessageFeature } from '@solana/wallet-standard-features';
import { WalletAccount, WalletIcon, WalletVersion } from '@wallet-standard/base';
import { StandardConnectFeature, StandardDisconnectFeature, StandardEventsFeature } from '@wallet-standard/features';
import { Transaction, VersionedTransaction, Cluster, SendOptions, TransactionSignature, Connection } from '@solana/web3.js';
import EventEmitter from 'eventemitter3';
import { SendTransactionOptions } from '@solana/wallet-adapter-base';
import 'react';
import 'viem';
import '@privy-io/js-sdk-core';
import '@privy-io/public-api';
import '@metamask/eth-sig-util';

interface UseImportWalletInterface {
    /**
     * Imports a private key to be used as an embedded wallet for the user
     * This method will error if the user already has an imported wallet or if they
     * exit in the middle of the flow.
     *
     * @param o Input object
     * @param o.privateKey The base58 private key of the solana wallet to import
     *
     * @returns The imported wallet
     */
    importWallet: (input: {
        privateKey: string;
    }) => Promise<Wallet>;
}
/**
 * Use this hook to import an external solana wallet into an embedded wallet via its private key
 *
 * @returns The `importWallet` method
 */
declare const useImportWallet: () => UseImportWalletInterface;

/**
 * Object representation of a Privy Solana wallet account.
 */
declare class PrivyWalletAccount implements WalletAccount {
    #private;
    get address(): string;
    get publicKey(): Uint8Array;
    get chains(): `${string}:${string}`[];
    get features(): `${string}:${string}`[];
    get label(): string | undefined;
    get icon(): `data:image/svg+xml;base64,${string}` | `data:image/webp;base64,${string}` | `data:image/png;base64,${string}` | `data:image/gif;base64,${string}` | undefined;
    constructor({ address, publicKey, label, icon }: Omit<WalletAccount, 'chains' | 'features'>);
}

/**
 * Standard wallet implementation interface
 */
interface StandardWalletImplementation {
    /**
     * Sign a message.
     */
    signMessage(message: Uint8Array, address: string): Promise<{
        signature: Uint8Array;
    }>;
    /**
     * Sign and send a transaction.
     */
    signAndSendTransaction<T extends Transaction | VersionedTransaction>(transaction: T, address: string, cluster: Cluster, options?: SendOptions): Promise<{
        signature: TransactionSignature;
    }>;
    /**
     * Sign a transaction without sending it to the network.
     */
    signTransaction<T extends Transaction | VersionedTransaction>(transaction: T, address: string, cluster: Cluster, options?: SendOptions): Promise<T>;
}
type StandardWalletInjectionEvents = {
    accountChanged: (accounts?: Array<{
        address: string;
    }>) => void;
};
/**
 * Event emitter for the provider solana injection.
 * This provides all the methods to sign messages, transactions, etc.
 * Implementation is updated everytime the references to the wallets change.
 */
declare class StandardWalletInjection extends EventEmitter<StandardWalletInjectionEvents> {
    #private;
    constructor(implementation: StandardWalletImplementation);
    setImplementation(implementation: StandardWalletImplementation): void;
    signMessage(message: Uint8Array, address: string): Promise<{
        signature: Uint8Array;
    }>;
    signAndSendTransaction<T extends Transaction | VersionedTransaction>(transaction: T, address: string, cluster: Cluster, options?: SendOptions): Promise<{
        signature: TransactionSignature;
    }>;
    signTransaction<T extends Transaction | VersionedTransaction>(transaction: T, address: string, cluster: Cluster, options?: SendOptions): Promise<T>;
}

type PrivyFeature = {
    'privy:': {
        privy: StandardWalletImplementation;
    };
};
/**
 * Privy standard wallet implementation.
 */
declare class PrivyStandardWallet implements SolanaStandardWallet {
    #private;
    get version(): "1.0.0";
    get name(): string;
    get icon(): `data:image/svg+xml;base64,${string}` | `data:image/webp;base64,${string}` | `data:image/png;base64,${string}` | `data:image/gif;base64,${string}`;
    get chains(): ("solana:mainnet" | "solana:devnet" | "solana:testnet")[];
    get features(): StandardConnectFeature & StandardDisconnectFeature & StandardEventsFeature & SolanaSignAndSendTransactionFeature & SolanaSignTransactionFeature & SolanaSignMessageFeature & PrivyFeature;
    get accounts(): PrivyWalletAccount[];
    get isPrivyWallet(): boolean;
    constructor({ name, icon, version, injection, wallets, }: {
        name: string;
        icon: WalletIcon;
        version: WalletVersion;
        injection: StandardWalletInjection;
        wallets: Array<{
            address: string;
        }>;
    });
}

/**
 * Use this hook to get Privy's implementation of the Standard Wallet interface.
 */
interface UsePrivyStandardWalletInterface {
    /**
     * Whether the wallet is ready to be used.
     */
    ready: boolean;
    /**
     * The wallet that implements the Standard Wallet interface.
     */
    wallet: PrivyStandardWallet;
}
/**
 * Use this hook to get Privy's implementation of the Standard Wallet interface.
 */
declare function usePrivyStandardWallet(): UsePrivyStandardWalletInterface;

/**
 * Use this hook to get the wallets that implement the Solana Standard Wallet interface.
 */
interface UseSolanaStandardWalletsInterface {
    /**
     * Whether the wallets are ready to be used.
     */
    ready: boolean;
    /**
     * The wallets that implement the Solana Standard Wallet interface.
     */
    wallets: SolanaStandardWallet[];
}
declare function useSolanaStandardWallets(): UseSolanaStandardWalletsInterface;

/**
 * Method to fund a user's Solana wallet via Privy's funding feature by inputting a valid wallet address.
 * You can access the fields and methods documented here via the {@link useFundWallet} hook.
 */
interface UseFundWalletInterface {
    /**
     * Prompt the user to go through the funding flow and for a specified wallet.
     *
     * This will open the modal with a prompt for the user to select a funding method (if multiple are enabled).
     *
     * Once the user continues to the funding flow, Privy will display the funding status screen, and wait
     * for the transaction to complete.
     *
     * Note: Even after a successful funding, funds can take a few minutes to arrive in the user's wallet.
     *
     * Privy currently supports funding via external wallets and Moonpay.
     *
     * @param address typed data payload to be signed
     * @param fundWalletConfig {@link SolanaFundingConfig} Funding configuration to specify chain and funding amount (if enabled)
     */
    fundWallet: (address: string, fundWalletConfig?: SolanaFundingConfig) => Promise<void>;
}
/**
 * Hook to fund a Solana wallet via Privy's fiat on-ramp integration given the wallet address.
 *
 * @param callbacks.onUserExited {@link PrivyEvents} Callback that will execute when a funding flow is exited. This fires when a user closes a funding flow modal, for any reason.
 * @returns fundWallet - function to on-ramp funds to any given Solana wallet
 */
declare const useFundWallet: (callbacks?: PrivyEvents["fundSolanaWallet"]) => UseFundWalletInterface;

declare const useSolanaFundingPlugin: () => void;

declare const useSolanaLedgerPlugin: () => void;

/**
 * Method to send a Solana transaction via a user's embedded wallet.
 * You can access the methods documented here via the {@link useSendTransaction} hook from `@privy-io/react-auth/solana`..
 */
interface UseSendTransactionInterface {
    /**
     * Prompts a user to send a transaction using their embedded wallet.
     *
     * This method will error if the user is not authenticated or does not have a solana embedded wallet.
     *
     * If the `config.embeddedWallets.showWalletUIs` property is set to false, the wallet will attempt to send
     * the transaction without prompting the user. Otherwise (the default), Privy will show the user a modal to have
     * them confirm the transaction. This can be customized via the {@link SendTransactionModalUIOptions}.
     *
     * @param o.transaction {SupportedSolanaTransaction} transaction to be sent
     * @param o.connection {Connection} Connection to an SVM (Solana) network.
     * @param o.uiOptions {@link SendTransactionModalUIOptions} (optional) UI options to customize the transaction request modal
     * @param o.transactionOptions {@link SendTransactionOptions} (optional) Transaction options to customize the transaction request
     * @param o.fundWalletConfig {@link SolanaFundingConfig} (optional) Funding configuration to specify cluster and funding amount (if enabled), in the case of insufficient funds
     * @param o.address {optional} address for the embedded wallet sending the transaction. Defaults to the user's embedded wallet at HD index 0.
     */
    sendTransaction: (o: {
        transaction: SupportedSolanaTransaction;
        connection: Connection;
        uiOptions?: SendTransactionModalUIOptions;
        transactionOptions?: SendTransactionOptions;
        fundWalletConfig?: SolanaFundingConfig;
        address?: string;
    }) => Promise<SolanaTransactionReceipt>;
}
/**
 * Use this hook to send a transaction using the embedded wallet and to attach callbacks for success and errors.
 * Transactions sent from the embedded wallet using transaction functions from non-Privy libraries
 * will not trigger the callbacks.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute for a successful transaction sent
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during `sendSolanaTransaction`
 * @returns sendSolanaTransaction - prompts the user send a transaction using their embedded wallet
 */
declare function useSendTransaction(callbacks?: PrivyEvents['sendSolanaTransaction']): UseSendTransactionInterface;

/**
 * Method to sign a Solana transaction via a user's embedded wallet.
 * You can access the methods documented here via the {@link useSignTransaction} hook from `@privy-io/react-auth/solana`..
 */
interface UseSignTransactionInterface {
    /**
     * Prompts a user to sign a transaction using their embedded wallet, without broadcasting the signed
     * transaction to the network.
     *
     * This method will error if the user is not authenticated or does not have a solana embedded wallet.
     *
     * If the `config.embeddedWallets.showWalletUIs` property is set to false, the wallet will attempt to send
     * the transaction without prompting the user. Otherwise (the default), Privy will show the user a modal to have
     * them confirm the transaction. This can be customized via the {@link SendTransactionModalUIOptions}.
     *
     * @param o.transaction {SupportedSolanaTransaction} transaction to sign
     * @param o.connection {Connection} Connection to an SVM (Solana) network.
     * @param o.uiOptions {@link SendTransactionModalUIOptions} (optional) UI options to customize the transaction request modal
     * @param o.transactionOptions {@link SendTransactionOptions} (optional) Transaction options to customize the transaction request
     * @param o.address {optional} address for the embedded wallet signing the transaction. Defaults to the user's embedded wallet at HD index 0.
     */
    signTransaction: (o: {
        transaction: SupportedSolanaTransaction;
        connection: Connection;
        uiOptions?: SendTransactionModalUIOptions;
        transactionOptions?: SendTransactionOptions;
        address?: string;
    }) => Promise<SupportedSolanaTransaction>;
}
/**
 * Use this hook to sign a transaction using a Solana embedded wallet and to attach callbacks for success and errors.
 * Transactions signed by the embedded wallet using transaction functions from non-Privy libraries
 * will not trigger the callbacks.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute for a successful transaction signed
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during signing the transaction
 * @returns signTransaction - prompts the user to sign a transaction using their embedded wallet
 */
declare function useSignTransaction(callbacks?: PrivyEvents['signSolanaTransaction']): UseSignTransactionInterface;

/**
 * Method to sign a Solana message via a user's embedded wallet.
 * You can access the methods documented here via the {@link useSignMessage} hook from `@privy-io/react-auth/solana`.
 */
interface UseSignMessageInterface {
    /**
     * Prompts a user to sign a message using their embedded wallet.
     *
     * This method will error if the user is not authenticated or does not have a solana embedded wallet.
     *
     * If the `config.embeddedWallets.showWalletUIs` property is set to false, the wallet will attempt to sign
     * the message without prompting the user. Otherwise (the default), Privy will show the user a modal to have
     * them confirm the message. This can be customized via the {@link SignMessageModalUIOptions}.
     *
     * @param args.message {Uint8Array} message to sign
     * @param args.options.uiOptions {@link SignMessageModalUIOptions} (optional) UI options to customize the message signing request modal
     * @param args.options.address (optional) address for the embedded wallet signing the message. Defaults to the user's embedded wallet at HD index 0.
     */
    signMessage: (args: {
        message: Uint8Array;
        options?: {
            uiOptions?: SignMessageModalUIOptions;
            address?: string;
        };
    }) => Promise<Uint8Array>;
}
/**
 * Use this hook to sign a message using a Solana embedded wallet and to attach callbacks for success and errors.
 *
 * @param callbacks.onSuccess {@link PrivyEvents} callback to execute for a successful message signed
 * @param callbacks.onError {@link PrivyEvents} callback to execute if there is an error during signing the message
 * @returns signMessage - prompts the user to sign a message using their embedded wallet
 */
declare function useSignMessage(callbacks?: PrivyEvents['signSolanaMessage']): {
    signMessage: ({ message: _message, options, }: {
        message: Uint8Array;
        options?: {
            address?: string;
            uiOptions?: SignMessageModalUIOptions;
        };
    }) => Promise<Uint8Array>;
};

export { PrivyStandardWallet, SolanaStandardWallet, SolanaTransactionReceipt, SupportedSolanaTransaction, type UseFundWalletInterface, type UseImportWalletInterface, type UsePrivyStandardWalletInterface, type UseSendTransactionInterface, type UseSignMessageInterface, type UseSignTransactionInterface, type UseSolanaStandardWalletsInterface, useFundWallet, useImportWallet, usePrivyStandardWallet, useSendTransaction, useSignMessage, useSignTransaction, useSolanaFundingPlugin, useSolanaLedgerPlugin, useSolanaStandardWallets };
