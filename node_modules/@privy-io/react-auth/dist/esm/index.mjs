import{u as e,g as t,a as r,b as o,c as i,d as n,C as s,e as l,s as d,P as h,f as w,h as p,i as m,G as f,W as k,j as C,k as W,l as v,m as P,n as _,o as x,p as j,q,r as G,t as X,v as $,w as Y,x as Z}from"./privy-provider-DkDa6JMm.mjs";export{A as Captcha,B as ConnectorManager,E as EthereumWalletConnector,U as LoginModal,M as PrivyClient,y as PrivyProvider,V as VERSION,D as WalletConnector,K as errorIndicatesMaxMfaRetries,L as errorIndicatesMfaTimeout,J as errorIndicatesMfaVerificationFailed,z as getAccessToken,R as useCreateWallet,N as useIdentityToken,T as useImportWallet,O as useLogout,H as useMfa,I as useMfaEnrollment,F as usePrivy,Q as useRegisterMfaListener,S as useSolanaWallets}from"./privy-provider-DkDa6JMm.mjs";import{useCallback as ee,useMemo as te,useEffect as re,useContext as oe,useRef as ie}from"react";import{u as ae,P as ne,a as se,I as le}from"./internal-context-tkv6NwcA.mjs";export{c as useActiveWallet,a as useConnectWallet,b as useFundWallet,u as useLogin}from"./useActiveWallet-Czp--Wb-.mjs";import{F as ce}from"./frame-8dYl0aUa.mjs";import{zeroAddress as ue,getAddress as de,createWalletClient as he,http as we,parseSignature as pe}from"viem";import{hashAuthorization as ge}from"viem/utils";import{getWallet as me,updateWallet as ye}from"@privy-io/js-sdk-core";export{DEFAULT_SUPPORTED_CHAINS as SUPPORTED_CHAINS,addPrivyRpcToChain,addRpcUrlOverrideToChain}from"@privy-io/js-sdk-core";export{g as getEmbeddedConnectedWallet}from"./getEmbeddedConnectedWallet-CSSBWE2p.mjs";import"react/jsx-runtime";import"mipd";import"react-device-detect";import"uuid";import"jose";import"eventemitter3";import"@coinbase/wallet-sdk";import"@privy-io/ethereum";import"@marsidev/react-turnstile";import"styled-components";import"tinycolor2";import"@heroicons/react/24/outline/DevicePhoneMobileIcon";import"@heroicons/react/24/outline/FingerPrintIcon";import"@heroicons/react/24/outline/PhoneIcon";import"@heroicons/react/24/outline/ShieldCheckIcon";import"@heroicons/react/24/outline/ArrowLeftIcon";import"@heroicons/react/24/outline/ArrowRightIcon";import"@heroicons/react/24/outline/QuestionMarkCircleIcon";import"@heroicons/react/24/outline/XMarkIcon";import"@heroicons/react/24/outline/ChevronDownIcon";import"@heroicons/react/24/outline/CalendarIcon";import"@heroicons/react/24/outline/ExclamationTriangleIcon";import"@headlessui/react";import"@walletconnect/ethereum-provider";import"zustand";import"fast-password-entropy";import"secure-password-utilities";import"secure-password-utilities/wordlists";import"@heroicons/react/24/outline/UserCircleIcon";import"@heroicons/react/24/outline/EnvelopeIcon";import"@heroicons/react/20/solid/CheckIcon";import"@heroicons/react/24/outline/WalletIcon";import"@heroicons/react/24/outline/CheckIcon";import"@heroicons/react/24/outline/Square2StackIcon";import"@heroicons/react/24/outline/ExclamationCircleIcon";import"@heroicons/react/24/outline/ArrowTopRightOnSquareIcon";import"@heroicons/react/24/solid/DocumentCheckIcon";import"@heroicons/react/24/solid/XCircleIcon";import"@heroicons/react/24/solid/CheckCircleIcon";import"qrcode";import"@heroicons/react/24/solid/ArrowsRightLeftIcon";import"@heroicons/react/24/outline/ChevronRightIcon";import"@heroicons/react/24/outline/LockClosedIcon";import"@heroicons/react/24/outline/PencilSquareIcon";import"@heroicons/react/24/outline/ArrowPathIcon";import"@heroicons/react/24/outline/EyeIcon";import"@heroicons/react/24/outline/EyeSlashIcon";import"@heroicons/react/24/outline/KeyIcon";import"@heroicons/react/24/outline/ArrowDownTrayIcon";import"@heroicons/react/24/outline/ClipboardDocumentCheckIcon";import"@heroicons/react/24/outline/DocumentDuplicateIcon";import"@heroicons/react/24/solid/LockClosedIcon";import"@heroicons/react/24/outline/CheckCircleIcon";import"@heroicons/react/24/outline/InformationCircleIcon";import"@heroicons/react/24/outline/CreditCardIcon";import"@heroicons/react/24/outline/QrCodeIcon";import"@heroicons/react/24/outline/GlobeAltIcon";import"ofetch";import"@heroicons/react/24/outline";import"@heroicons/react/24/outline/ClipboardDocumentIcon";import"@heroicons/react/24/outline/CloudArrowUpIcon";import"@heroicons/react/24/outline/NoSymbolIcon";import"@heroicons/react/24/outline/ClockIcon";import"@heroicons/react/24/outline/TrashIcon";import"@heroicons/react/24/solid/CheckBadgeIcon";import"@heroicons/react/24/solid/IdentificationIcon";import"@heroicons/react/24/outline/MinusCircleIcon";import"@heroicons/react/24/outline/ArrowRightEndOnRectangleIcon";import"@heroicons/react/24/solid/ShieldCheckIcon";import"js-cookie";const Ae=()=>{let{user:o}=e(),{walletProxy:i}=ae();return{recover:ee((async e=>{if(!i)throw Error("Wallet proxy is not ready");let a=await t();if(!o||!a)throw new ne("User must be logged in before attempting to modify the recovery method.");let{entropyId:n,entropyIdVerifier:s}=r(o);try{await i.recover({entropyId:n,entropyIdVerifier:s,accessToken:a,...e})}catch{throw new ne("Unable to recover wallets")}}),[i,o])}},fe=()=>{let{client:e,setAuthenticated:t,setUser:r}=ae();return te((()=>({init:async()=>{if(!e)throw new ne("Must initialize Privy client first.");let t=new ce;return e.startAuthFlow(t),await t.init()},login:async({fid:o,message:i,signature:a})=>{if(!e)throw new ne("Must initialize Privy client first.");if(!(e.authFlow instanceof ce))throw new ne("Must initialize Farcaster frame flow first.");e.authFlow.setAuthData({message:i,signature:a,fid:o});let{user:n}=await e.authenticate();if(!n)throw new ne("Failed to login with Farcaster V2");return r(n),t(!0),{user:n}}})),[e,r,t])},ke=t=>{o("login",t);let r=i(),a=n(),{ready:c,user:u}=e(),{initLoginWithHeadlessOAuth:h,loginWithHeadlessOAuth:w,oAuthState:p,setOAuthState:g,isHeadlessOAuthLoading:m}=ae(),y=ee((async e=>{try{if(r.enabled&&"success"!==r.status)throw new s(r.error,null,se.CAPTCHA_FAILURE);return await h(e.provider,r.token,e.disableSignup)}catch(e){throw g({status:"error",error:e}),e}}),[h,r]),A=ee((async()=>{let e=l();try{if(u)return console.warn("Cannot login with OAuth when already logged in"),u;if(!e.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");if(e.popupFlow)return}catch(e){throw g({status:"error",error:e}),e}try{return await w(e)}catch(e){throw g({status:"error",error:e}),e}finally{d()}}),[w]);return re((()=>{let e=l();c&&a&&e.inProgress&&!e.withPrivyUi&&!e.popupFlow&&A().catch((()=>{}))}),[c,a]),{initOAuth:y,loading:m,state:p}},Ce=e=>{let t=i(),{emailOtpState:r,setEmailOtpState:o,initLoginWithEmail:a,loginWithCode:n}=ae();return{sendCode:ee((async({email:r,disableSignup:i})=>{try{let e;if(!r)throw Error("Email required to send OTP code");if(t.enabled&&"error"===t.status)throw new s(t.error,null,se.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await a({email:r,captchaToken:e,disableSignup:i,withPrivyUi:!1})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||se.UNKNOWN_AUTH_ERROR),r}}),[a]),loginWithCode:ee((async({code:r})=>{try{if(t.enabled&&"error"===t.status)throw new s(t.error,null,se.CAPTCHA_FAILURE);let{user:o,isNewUser:i,wasAlreadyAuthenticated:a,linkedAccount:l}=await n(r);e?.onComplete?.({user:o,isNewUser:i,wasAlreadyAuthenticated:a,loginMethod:"email",loginAccount:l})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||se.UNKNOWN_AUTH_ERROR),r}}),[n,t.status]),state:r}},Ie=e=>{let t=i(),{initSignupWithPasskey:r,signupWithPasskey:o,passkeyAuthState:a,setPasskeyAuthState:n}=ae();return{signupWithPasskey:ee((async()=>{try{let i;if(t.enabled&&"error"===t.status)throw new s(t.error,null,se.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),i=await t.waitForResult()),await r({captchaToken:i,withPrivyUi:!1});let{user:a,isNewUser:n,wasAlreadyAuthenticated:l,loginAccount:c}=await o();e?.onComplete?.({user:a,isNewUser:n,wasAlreadyAuthenticated:l,loginMethod:"passkey",loginAccount:c})}catch(t){throw n({status:"error",error:t}),e?.onError?.(t.privyErrorCode||se.UNKNOWN_AUTH_ERROR),t}}),[o,t.status]),state:a}},We=e=>{let t=i(),{initLoginWithPasskey:r,loginWithPasskey:o,passkeyAuthState:a,setPasskeyAuthState:n}=ae();return{loginWithPasskey:ee((async i=>{try{let a;if(t.enabled&&"error"===t.status)throw new s(t.error,null,se.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),a=await t.waitForResult()),await r({captchaToken:a,withPrivyUi:!1});let{user:n,isNewUser:l,wasAlreadyAuthenticated:c,loginAccount:u}=await o(i);e?.onComplete?.({user:n,isNewUser:l,wasAlreadyAuthenticated:c,loginMethod:"passkey",loginAccount:u})}catch(i){throw n({status:"error",error:i}),e?.onError?.(i.privyErrorCode||se.UNKNOWN_AUTH_ERROR),i}}),[o,t.status]),state:a}},Ee=e=>{let{initLinkWithPasskey:t,linkWithPasskey:r,passkeyAuthState:o,setPasskeyAuthState:i}=ae();return{linkWithPasskey:ee((async()=>{try{await t();let o=await r();if(!o)throw Error("Error, user not found");let i=o.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:o,linkMethod:"passkey",linkedAccount:i})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||se.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),t}}),[r]),state:o}},Te=e=>{let t=i(),{smsOtpState:r,setSmsOtpState:o,initLoginWithSms:a,loginWithCode:n}=ae();return{sendCode:ee((async({phoneNumber:r,disableSignup:i})=>{try{let e;if(!r)throw Error("SMS required to send OTP code");if(t.enabled&&"error"===t.status)throw new s(t.error,null,se.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await a({phoneNumber:r,captchaToken:e,disableSignup:i,withPrivyUi:!1})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||se.UNKNOWN_AUTH_ERROR),r}}),[a]),loginWithCode:ee((async({code:r})=>{try{if(t.enabled&&"success"!==t.status)throw new s(t.error,null,se.CAPTCHA_FAILURE);let{user:o,isNewUser:i,wasAlreadyAuthenticated:a,linkedAccount:l}=await n(r);e?.onComplete?.({user:o,isNewUser:i,wasAlreadyAuthenticated:a,loginMethod:"sms",loginAccount:l})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||se.UNKNOWN_AUTH_ERROR),r}}),[n,t.status]),state:r}},Ue=t=>{let{connectOrCreateWallet:r}=e();return o("connectOrCreateWallet",t),{connectOrCreateWallet:r}},Se=e=>{let t=i(),{siweState:r,setSiweState:o,linkWithSiwe:a,generateSiweMessage:n}=ae();return{generateSiweMessage:ee((async({address:t,chainId:r})=>{try{if(!t||!r)throw Error("wallet address and chainId required to generate nonce");return await n({address:t,chainId:r}).then((e=>e))}catch(t){throw o({status:"error",error:t}),e?.onError?.(t.privyErrorCode||se.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),t}}),[n]),linkWithSiwe:ee((async({signature:r,message:i,chainId:n,walletClientType:l,connectorType:c})=>{try{if(t.enabled&&"success"!==t.status)throw new s(t.error,null,se.CAPTCHA_FAILURE);let{user:o,linkedAccount:u}=await a({message:i,signature:r,chainId:n,walletClientType:l,connectorType:c});u&&e?.onSuccess?.({user:o,linkMethod:"siwe",linkedAccount:u})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||se.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),r}}),[a,t.status]),state:r}},ve=e=>{let t=i(),{siweState:r,setSiweState:o,client:a,generateSiweMessage:n,loginWithSiwe:l}=ae();return{generateSiweNonce:ee((async({address:r})=>{try{let e;if(t.enabled&&"error"===t.status)throw new s(t.error,null,se.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),o({status:"generating-message"});let i=await a.generateSiweNonce({address:r,captchaToken:e});return o({status:"awaiting-signature"}),i}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||se.UNKNOWN_AUTH_ERROR),r}}),[a,t]),generateSiweMessage:ee((async({address:t,chainId:r})=>{try{return await n({address:t,chainId:r})}catch(t){throw o({status:"error",error:t}),e?.onError?.(t.privyErrorCode||se.UNKNOWN_AUTH_ERROR),t}}),[n]),loginWithSiwe:ee((async({message:r,signature:i,disableSignup:a})=>{try{let o;if(t.enabled&&"error"===t.status)throw new s(t.error,null,se.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),o=await t.waitForResult());let n=await l({message:r,signature:i,captchaToken:o,disableSignup:a});return e?.onComplete?.({user:n,isNewUser:!1,wasAlreadyAuthenticated:!1,loginMethod:"siwe",loginAccount:null}),n}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||se.UNKNOWN_AUTH_ERROR),r}}),[l,t.status]),state:r}};function Re(){let{signTransaction:e}=oe(h);return{signTransaction:e}}function be(e){let{linkEmail:t,linkPhone:r,linkWallet:i,linkGoogle:a,linkApple:n,linkTwitter:s,linkDiscord:l,linkGithub:c,linkLinkedIn:u,linkTiktok:d,linkSpotify:w,linkInstagram:p,linkTelegram:g,linkFarcaster:m}=oe(h);return o("linkAccount",e),{linkEmail:t,linkPhone:r,linkWallet:i,linkGoogle:a,linkApple:n,linkTwitter:s,linkDiscord:l,linkGithub:c,linkLinkedIn:u,linkTiktok:d,linkSpotify:w,linkInstagram:p,linkFarcaster:m,linkTelegram:g}}function Pe(e){let{updateEmail:t,updatePhone:r}=oe(h);return o("update",e),{updateEmail:t,updatePhone:r}}const Ne=()=>{let{connectCoinbaseSmartWallet:e}=ae();return{connectCoinbaseSmartWallet:e}},Oe=()=>{let{startCrossAppAuthFlow:t,unlinkCrossAppAccount:r,signMessageWithCrossAppWallet:o,signTypedDataWithCrossAppWallet:i,sendTransactionWithCrossAppWallet:a}=e();return{loginWithCrossAppAccount:({appId:e})=>t({appId:e,action:"login"}),linkCrossAppAccount:({appId:e})=>t({appId:e,action:"link"}),unlinkCrossAppAccount:r,signMessage:o,signTypedData:i,sendTransaction:a}};function _e(e){let{sendTransaction:t}=oe(h);return o("sendTransaction",e),{sendTransaction:t}}function Me(e){let{setWalletPassword:t}=oe(h);return o("setWalletPassword",e),{setWalletPassword:t}}function Fe(){let t=w(),{getAccessToken:r}=e(),o=p(),{client:i,setUser:a,setAuthenticated:n,setIsNewUser:s,initializeWalletProxy:l}=ae(),{create:c}=m();return{createGuestAccount:async()=>{if(!t.id||!i)throw Error("SDK not yet ready");i.startAuthFlow(new f(t.id));try{let e=await i.authenticate(),u=e.user,d=e.isNewUser??!1;if(!u)throw new ne("Unable to authenticate guest account");let h=await r(),w=await l(k);if(h&&w)try{let e=C(u,t.embeddedWallets.ethereum.createOnLogin),r=W(u,t.embeddedWallets.solana.createOnLogin);e&&r?(u=(await c({chainType:"ethereum",latestUser:u})).user,u=(await c({chainType:"solana",latestUser:u})).user):r?u=(await c({chainType:"solana",latestUser:u})).user:e?u=(await c({chainType:"ethereum",latestUser:u})).user:a(u)}catch(e){a(u),console.warn("Unable to create embedded wallet for guest account")}return s(d),n(!0),o("login","onComplete",{user:u,isNewUser:d,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),u}catch(e){throw o("login","onError",e.privyErrorCode||se.UNKNOWN_AUTH_ERROR),e}}}}function Le(e){let{setWalletRecovery:t}=oe(h);return o("setWalletRecovery",e),{setWalletRecovery:t}}function He(e){let{signMessage:t}=oe(h);return o("signMessage",e),{signMessage:t}}const De=()=>{let{ready:t,wallets:r}=v(),{user:o}=e(),{rpcConfig:i,chains:a,appId:n}=ae();return{signAuthorization:ee((async(e,s)=>{if(!o)throw Error("User must be authenticated before signing with a Privy wallet");if(!t)throw Error("Wallets are not ready");let l=s?.address??P(o)?.address??ue,c=r.find((e=>de(e.address)===de(l)));if(!c)throw Error("Signing wallet not found.");let u=e.chainId??Number(c.chainId.split(":")[1]),d=a.find((e=>e.id===u));if(!d)throw Error("Error, chain not configured in PrivyProvider config");let h=he({account:l,chain:d,transport:we(_(d,i,n))}),w=await h.prepareAuthorization({...e}),p=await c.getEthereumProvider(),g=await p.request({method:"secp256k1_sign",params:[ge(w)]});return{...w,...pe(g)}}),[t,r,o,a])}};function xe(e){let{signTypedData:t}=oe(h);return o("signTypedData",e),{signTypedData:t}}const Ke=()=>{let{isModalOpen:e}=oe(h);return{isOpen:e}};function ze(e){let{getAccessToken:t}=oe(h);return o("accessToken",e),{getAccessToken:t}}function je(t){let{authenticated:r,user:i}=e(),{initLoginWithOAuth:a}=ae(),n=p();return o("oAuthAuthorization",t),{reauthorize:e=>qe(r,i,a,n,e.provider)}}let qe=async(e,t,r,o,i)=>{if(!e)throw o("linkAccount","onError",se.MUST_BE_AUTHENTICATED,{linkMethod:i}),new ne("User must be authenticated before linking an account.");if(!t?.linkedAccounts.some((e=>e.type.includes(i))))throw new ne(`OAuth account of type ${i} not linked to the account.`);await r(i)};const Ve=e=>{let t=x();return o("customAuth",e),{status:t}};function Ge({isAuthenticated:e,isLoading:t,...r}){let o=ie();re((()=>{t||o.current?.()}),[e,t]);let i=ee((e=>(o.current=e,()=>{o.current=void 0})),[]);return j({...r,subscribe:i})}function Be(){let{getFarcasterSignerPublicKey:t,signFarcasterMessage:r,requestFarcasterSignerFromWarpcast:o}=e();return{getFarcasterSignerPublicKey:t,signFarcasterMessage:r,requestFarcasterSignerFromWarpcast:o}}const Qe=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=ae();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},Xe=()=>{let{addSessionSignersInternal:t,removeSessionSignersInternal:r}=(()=>{let{getAccessToken:t,user:r}=e(),o=ae(),{signWithUserSigner:i}=q(),a=async({wallet:e,additional_signers:a})=>{let n=await t();if(!r||!n)throw new ne("User must be authenticated and have an embedded wallet to delegate actions.");if(!e.id)throw new ne("Wallet to add signers to must have ID on server");if(!o.walletProxy)throw new ne("Wallet proxy not initialized.");await ye(o.privy,{wallet_id:e.id},i,{additional_signers:a})};return{addSessionSignersInternal:async({address:e,signers:i})=>{let n=await t();if(!r||!n)throw new ne("User must be authenticated and have an embedded wallet to add a session signer.");let s=o.walletProxy??await o.initializeWalletProxy(15e3);if(!s)throw new ne("Wallet proxy not initialized.");let l=G(r,e);if(!l)throw new ne("Address to add signers too is not associated with current user.");if(X(l)){if(0===i.length)throw new ne("Must specify at least one signer to add.");let e=[...(await me(o.privy,{wallet_id:l.id})).additional_signers,...$(i)];await a({wallet:l,additional_signers:e})}else{if(l.delegated)return{user:r};if(i.length>0)throw new ne("This embedded wallet does not support specifying signers. If signing is enabled in the dashboard, signer will default to that key. Otherwise, no signatures will be required for the wallet.");let t=Y({address:e,user:r}),a=Z({address:e,user:r});await o.recoverEmbeddedWallet({address:e}),await s.createDelegatedAction({accessToken:n,rootWallet:a,delegatedWallets:[t]})}let c=await o.refreshSessionAndUser();if(!c)throw Error("Could not refresh user");return{user:c}},removeSessionSignersInternal:async({address:e})=>{let i=await t();if(!r||!i)throw new ne("User must be authenticated and have an embedded wallet to delegate actions.");if(!(o.walletProxy??await o.initializeWalletProxy(15e3)))throw new ne("Wallet proxy not initialized.");let n=G(r,e);if(!n)throw new ne("Address to remove signers from is not associated with current user.");X(n)?await a({wallet:n,additional_signers:[]}):await o.client.revokeDelegatedWallet();let s=await o.refreshSessionAndUser();if(!s)throw Error("Could not refresh user");return{user:s}}}})();return{addSessionSigners:async({address:e,signers:r})=>t({address:e,signers:r}),removeSessionSigners:async({address:e})=>r({address:e})}},Je=()=>{let{setUser:e,client:t}=oe(le),{user:r}=oe(h);return{user:r,refreshUser:ee((async()=>{let r=await(t?.updateUserAndIdToken());return e(r??null),r}),[t,e])}},$e=e=>{let t=i(),{initLoginWithTelegram:r,loginWithTelegram:o,telegramAuthState:a,setTelegramAuthState:n}=ae();return{login:ee((async i=>{try{if(t.enabled&&"success"!==t.status)throw new s(t.error,null,se.CAPTCHA_FAILURE);await r(t.token,i?.disableSignup);let{user:a,isNewUser:n,loginAccount:l,wasAlreadyAuthenticated:c}=await o({intent:"login"});e?.onComplete?.({user:a,isNewUser:n,wasAlreadyAuthenticated:c,loginMethod:"telegram",loginAccount:l})}catch(i){throw n({status:"error",error:i}),e?.onError?.(i.privyErrorCode||se.UNKNOWN_AUTH_ERROR),i}}),[r,o,t]),state:a}},Ye=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=ae();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}};export{Ne as useConnectCoinbaseSmartWallet,Ue as useConnectOrCreateWallet,Oe as useCrossAppAccounts,Ve as useCustomAuth,Qe as useDelegatedActions,Be as useFarcasterSigner,Fe as useGuestAccounts,Ye as useHeadlessDelegatedActions,be as useLinkAccount,Ee as useLinkWithPasskey,Se as useLinkWithSiwe,Ce as useLoginWithEmail,fe as useLoginWithFarcasterV2,ke as useLoginWithOAuth,We as useLoginWithPasskey,ve as useLoginWithSiwe,Te as useLoginWithSms,$e as useLoginWithTelegram,Ke as useModalStatus,je as useOAuthTokens,Ae as useRecoverEmbeddedWallet,_e as useSendTransaction,Xe as useSessionSigners,Me as useSetWalletPassword,Le as useSetWalletRecovery,De as useSignAuthorization,He as useSignMessage,Re as useSignTransaction,xe as useSignTypedData,Ie as useSignupWithPasskey,Ge as useSubscribeToJwtAuthWithFlag,j as useSyncJwtBasedAuthState,ze as useToken,Pe as useUpdateAccount,Je as useUser,v as useWallets};
