"use strict";var e=require("./privy-provider-DFRGMmYo.js"),r=require("react"),t=require("./internal-context-Bj24LJZ_.js"),i=require("./useActiveWallet-CmsIBqAk.js"),o=require("./frame-mbQ9YqJg.js"),s=require("viem"),n=require("viem/utils"),a=require("@privy-io/js-sdk-core"),l=require("./getEmbeddedConnectedWallet-DTU4T9TJ.js");require("react/jsx-runtime"),require("mipd"),require("react-device-detect"),require("uuid"),require("jose"),require("eventemitter3"),require("@coinbase/wallet-sdk"),require("@privy-io/ethereum"),require("@marsidev/react-turnstile"),require("styled-components"),require("tinycolor2"),require("@heroicons/react/24/outline/DevicePhoneMobileIcon"),require("@heroicons/react/24/outline/FingerPrintIcon"),require("@heroicons/react/24/outline/PhoneIcon"),require("@heroicons/react/24/outline/ShieldCheckIcon"),require("@heroicons/react/24/outline/ArrowLeftIcon"),require("@heroicons/react/24/outline/ArrowRightIcon"),require("@heroicons/react/24/outline/QuestionMarkCircleIcon"),require("@heroicons/react/24/outline/XMarkIcon"),require("@heroicons/react/24/outline/ChevronDownIcon"),require("@heroicons/react/24/outline/CalendarIcon"),require("@heroicons/react/24/outline/ExclamationTriangleIcon"),require("@headlessui/react"),require("@walletconnect/ethereum-provider"),require("zustand"),require("fast-password-entropy"),require("secure-password-utilities"),require("secure-password-utilities/wordlists"),require("@heroicons/react/24/outline/UserCircleIcon"),require("@heroicons/react/24/outline/EnvelopeIcon"),require("@heroicons/react/20/solid/CheckIcon"),require("@heroicons/react/24/outline/WalletIcon"),require("@heroicons/react/24/outline/CheckIcon"),require("@heroicons/react/24/outline/Square2StackIcon"),require("@heroicons/react/24/outline/ExclamationCircleIcon"),require("@heroicons/react/24/outline/ArrowTopRightOnSquareIcon"),require("@heroicons/react/24/solid/DocumentCheckIcon"),require("@heroicons/react/24/solid/XCircleIcon"),require("@heroicons/react/24/solid/CheckCircleIcon"),require("qrcode"),require("@heroicons/react/24/solid/ArrowsRightLeftIcon"),require("@heroicons/react/24/outline/ChevronRightIcon"),require("@heroicons/react/24/outline/LockClosedIcon"),require("@heroicons/react/24/outline/PencilSquareIcon"),require("@heroicons/react/24/outline/ArrowPathIcon"),require("@heroicons/react/24/outline/EyeIcon"),require("@heroicons/react/24/outline/EyeSlashIcon"),require("@heroicons/react/24/outline/KeyIcon"),require("@heroicons/react/24/outline/ArrowDownTrayIcon"),require("@heroicons/react/24/outline/ClipboardDocumentCheckIcon"),require("@heroicons/react/24/outline/DocumentDuplicateIcon"),require("@heroicons/react/24/solid/LockClosedIcon"),require("@heroicons/react/24/outline/CheckCircleIcon"),require("@heroicons/react/24/outline/InformationCircleIcon"),require("@heroicons/react/24/outline/CreditCardIcon"),require("@heroicons/react/24/outline/QrCodeIcon"),require("@heroicons/react/24/outline/GlobeAltIcon"),require("ofetch"),require("@heroicons/react/24/outline"),require("@heroicons/react/24/outline/ClipboardDocumentIcon"),require("@heroicons/react/24/outline/CloudArrowUpIcon"),require("@heroicons/react/24/outline/NoSymbolIcon"),require("@heroicons/react/24/outline/ClockIcon"),require("@heroicons/react/24/outline/TrashIcon"),require("@heroicons/react/24/solid/CheckBadgeIcon"),require("@heroicons/react/24/solid/IdentificationIcon"),require("@heroicons/react/24/outline/MinusCircleIcon"),require("@heroicons/react/24/outline/ArrowRightEndOnRectangleIcon"),require("@heroicons/react/24/solid/ShieldCheckIcon"),require("js-cookie");let u=async(e,r,i,o,s)=>{if(!e)throw o("linkAccount","onError",t.PrivyErrorCode.MUST_BE_AUTHENTICATED,{linkMethod:s}),new t.PrivyClientError("User must be authenticated before linking an account.");if(!r?.linkedAccounts.some((e=>e.type.includes(s))))throw new t.PrivyClientError(`OAuth account of type ${s} not linked to the account.`);await i(s)};exports.Captcha=e.Captcha,exports.ConnectorManager=e.ConnectorManager,exports.EthereumWalletConnector=e.EthereumWalletConnector,exports.LoginModal=e.LoginModal,exports.PrivyClient=e.PrivyClient,exports.PrivyProvider=e.PrivyProvider,exports.VERSION=e.VERSION,exports.WalletConnector=e.WalletConnector,exports.errorIndicatesMaxMfaRetries=e.errorIndicatesMaxMfaRetries,exports.errorIndicatesMfaTimeout=e.errorIndicatesMfaTimeout,exports.errorIndicatesMfaVerificationFailed=e.errorIndicatesMfaVerificationFailed,exports.getAccessToken=e.getCustomerAccessToken,exports.useCreateWallet=e.useCreateWallet,exports.useIdentityToken=e.useIdentityToken,exports.useImportWallet=e.useImportWallet,exports.useLogout=e.useLogout,exports.useMfa=e.useMfa,exports.useMfaEnrollment=e.useMfaEnrollment,exports.usePrivy=e.usePrivy,exports.useRegisterMfaListener=e.useRegisterMfaListener,exports.useSolanaWallets=e.useSolanaWallets,exports.useSyncJwtBasedAuthState=e.useSyncJwtBasedAuthState,exports.useWallets=e.useWallets,exports.useActiveWallet=i.useActiveWallet,exports.useConnectWallet=i.useConnectWallet,exports.useFundWallet=i.useFundWallet,exports.useLogin=i.useLogin,Object.defineProperty(exports,"SUPPORTED_CHAINS",{enumerable:!0,get:function(){return a.DEFAULT_SUPPORTED_CHAINS}}),Object.defineProperty(exports,"addPrivyRpcToChain",{enumerable:!0,get:function(){return a.addPrivyRpcToChain}}),Object.defineProperty(exports,"addRpcUrlOverrideToChain",{enumerable:!0,get:function(){return a.addRpcUrlOverrideToChain}}),exports.getEmbeddedConnectedWallet=l.getEmbeddedConnectedWallet,exports.useConnectCoinbaseSmartWallet=()=>{let{connectCoinbaseSmartWallet:e}=t.usePrivyInternal();return{connectCoinbaseSmartWallet:e}},exports.useConnectOrCreateWallet=r=>{let{connectOrCreateWallet:t}=e.usePrivyContext();return e.usePrivyEventSubscription("connectOrCreateWallet",r),{connectOrCreateWallet:t}},exports.useCrossAppAccounts=()=>{let{startCrossAppAuthFlow:r,unlinkCrossAppAccount:t,signMessageWithCrossAppWallet:i,signTypedDataWithCrossAppWallet:o,sendTransactionWithCrossAppWallet:s}=e.usePrivyContext();return{loginWithCrossAppAccount:({appId:e})=>r({appId:e,action:"login"}),linkCrossAppAccount:({appId:e})=>r({appId:e,action:"link"}),unlinkCrossAppAccount:t,signMessage:i,signTypedData:o,sendTransaction:s}},exports.useCustomAuth=r=>{let t=e.useJwtAuthFlowState();return e.usePrivyEventSubscription("customAuth",r),{status:t}},exports.useDelegatedActions=()=>{let{revokeDelegatedWallets:e,delegateWallet:r}=t.usePrivyInternal();return{delegateWallet:async({address:e,chainType:t})=>await r({address:e,chainType:t,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},exports.useFarcasterSigner=function(){let{getFarcasterSignerPublicKey:r,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:i}=e.usePrivyContext();return{getFarcasterSignerPublicKey:r,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:i}},exports.useGuestAccounts=function(){let r=e.useAppConfig(),{getAccessToken:i}=e.usePrivyContext(),o=e.useEmitPrivyEvent(),{client:s,setUser:n,setAuthenticated:a,setIsNewUser:l,initializeWalletProxy:u}=t.usePrivyInternal(),{create:c}=e.useCreateWalletInternal();return{createGuestAccount:async()=>{if(!r.id||!s)throw Error("SDK not yet ready");s.startAuthFlow(new e.GuestFlow(r.id));try{let d=await s.authenticate(),h=d.user,y=d.isNewUser??!1;if(!h)throw new t.PrivyClientError("Unable to authenticate guest account");let w=await i(),p=await u(e.WALLET_PROXY_TIMEOUT);if(w&&p)try{let t=e.shouldCreateEmbeddedEthWallet(h,r.embeddedWallets.ethereum.createOnLogin),i=e.shouldCreateEmbeddedSolWallet(h,r.embeddedWallets.solana.createOnLogin);t&&i?(h=(await c({chainType:"ethereum",latestUser:h})).user,h=(await c({chainType:"solana",latestUser:h})).user):i?h=(await c({chainType:"solana",latestUser:h})).user:t?h=(await c({chainType:"ethereum",latestUser:h})).user:n(h)}catch(e){n(h),console.warn("Unable to create embedded wallet for guest account")}return l(y),a(!0),o("login","onComplete",{user:h,isNewUser:y,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),h}catch(e){throw o("login","onError",e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}}}},exports.useHeadlessDelegatedActions=()=>{let{revokeDelegatedWallets:e,delegateWallet:r}=t.usePrivyInternal();return{delegateWallet:async({address:e,chainType:t})=>await r({address:e,chainType:t,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}},exports.useLinkAccount=function(t){let{linkEmail:i,linkPhone:o,linkWallet:s,linkGoogle:n,linkApple:a,linkTwitter:l,linkDiscord:u,linkGithub:c,linkLinkedIn:d,linkTiktok:h,linkSpotify:y,linkInstagram:w,linkTelegram:p,linkFarcaster:g}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("linkAccount",t),{linkEmail:i,linkPhone:o,linkWallet:s,linkGoogle:n,linkApple:a,linkTwitter:l,linkDiscord:u,linkGithub:c,linkLinkedIn:d,linkTiktok:h,linkSpotify:y,linkInstagram:w,linkFarcaster:g,linkTelegram:p}},exports.useLinkWithPasskey=e=>{let{initLinkWithPasskey:i,linkWithPasskey:o,passkeyAuthState:s,setPasskeyAuthState:n}=t.usePrivyInternal();return{linkWithPasskey:r.useCallback((async()=>{try{await i();let r=await o();if(!r)throw Error("Error, user not found");let t=r.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,r)=>r.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:r,linkMethod:"passkey",linkedAccount:t})}catch(r){throw n({status:"error",error:r}),e?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),r}}),[o]),state:s}},exports.useLinkWithSiwe=i=>{let o=e.useCaptcha(),{siweState:s,setSiweState:n,linkWithSiwe:a,generateSiweMessage:l}=t.usePrivyInternal();return{generateSiweMessage:r.useCallback((async({address:e,chainId:r})=>{try{if(!e||!r)throw Error("wallet address and chainId required to generate nonce");return await l({address:e,chainId:r}).then((e=>e))}catch(e){throw n({status:"error",error:e}),i?.onError?.(e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),e}}),[l]),linkWithSiwe:r.useCallback((async({signature:r,message:s,chainId:l,walletClientType:u,connectorType:c})=>{try{if(o.enabled&&"success"!==o.status)throw new e.CaptchaError(o.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);let{user:n,linkedAccount:d}=await a({message:s,signature:r,chainId:l,walletClientType:u,connectorType:c});d&&i?.onSuccess?.({user:n,linkMethod:"siwe",linkedAccount:d})}catch(r){throw n({status:"error",error:r}),i?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),r}}),[a,o.status]),state:s}},exports.useLoginWithEmail=i=>{let o=e.useCaptcha(),{emailOtpState:s,setEmailOtpState:n,initLoginWithEmail:a,loginWithCode:l}=t.usePrivyInternal();return{sendCode:r.useCallback((async({email:r,disableSignup:s})=>{try{let i;if(!r)throw Error("Email required to send OTP code");if(o.enabled&&"error"===o.status)throw new e.CaptchaError(o.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);return o.enabled&&"success"!==o.status&&(o.execute(),i=await o.waitForResult()),await a({email:r,captchaToken:i,disableSignup:s,withPrivyUi:!1})}catch(r){throw n({status:"error",error:r}),i?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[a]),loginWithCode:r.useCallback((async({code:r})=>{try{if(o.enabled&&"error"===o.status)throw new e.CaptchaError(o.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);let{user:s,isNewUser:n,wasAlreadyAuthenticated:a,linkedAccount:u}=await l(r);i?.onComplete?.({user:s,isNewUser:n,wasAlreadyAuthenticated:a,loginMethod:"email",loginAccount:u})}catch(r){throw n({status:"error",error:r}),i?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[l,o.status]),state:s}},exports.useLoginWithFarcasterV2=()=>{let{client:e,setAuthenticated:i,setUser:s}=t.usePrivyInternal();return r.useMemo((()=>({init:async()=>{if(!e)throw new t.PrivyClientError("Must initialize Privy client first.");let r=new o.FarcasterFramesFlow;return e.startAuthFlow(r),await r.init()},login:async({fid:r,message:n,signature:a})=>{if(!e)throw new t.PrivyClientError("Must initialize Privy client first.");if(!(e.authFlow instanceof o.FarcasterFramesFlow))throw new t.PrivyClientError("Must initialize Farcaster frame flow first.");e.authFlow.setAuthData({message:n,signature:a,fid:r});let{user:l}=await e.authenticate();if(!l)throw new t.PrivyClientError("Failed to login with Farcaster V2");return s(l),i(!0),{user:l}}})),[e,s,i])},exports.useLoginWithOAuth=i=>{e.usePrivyEventSubscription("login",i);let o=e.useCaptcha(),s=e.useIsServerConfigLoaded(),{ready:n,user:a}=e.usePrivyContext(),{initLoginWithHeadlessOAuth:l,loginWithHeadlessOAuth:u,oAuthState:c,setOAuthState:d,isHeadlessOAuthLoading:h}=t.usePrivyInternal(),y=r.useCallback((async r=>{try{if(o.enabled&&"success"!==o.status)throw new e.CaptchaError(o.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);return await l(r.provider,o.token,r.disableSignup)}catch(r){throw d({status:"error",error:r}),r}}),[l,o]),w=r.useCallback((async()=>{let r=e.detectCompletingOAuthFlow();try{if(a)return console.warn("Cannot login with OAuth when already logged in"),a;if(!r.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");if(r.popupFlow)return}catch(r){throw d({status:"error",error:r}),r}try{return await u(r)}catch(r){throw d({status:"error",error:r}),r}finally{e.stripUrlOAuthParamsAndRemoveStateCode()}}),[u]);return r.useEffect((()=>{let r=e.detectCompletingOAuthFlow();n&&s&&r.inProgress&&!r.withPrivyUi&&!r.popupFlow&&w().catch((()=>{}))}),[n,s]),{initOAuth:y,loading:h,state:c}},exports.useLoginWithPasskey=i=>{let o=e.useCaptcha(),{initLoginWithPasskey:s,loginWithPasskey:n,passkeyAuthState:a,setPasskeyAuthState:l}=t.usePrivyInternal();return{loginWithPasskey:r.useCallback((async r=>{try{let a;if(o.enabled&&"error"===o.status)throw new e.CaptchaError(o.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);o.enabled&&"success"!==o.status&&(o.execute(),a=await o.waitForResult()),await s({captchaToken:a,withPrivyUi:!1});let{user:l,isNewUser:u,wasAlreadyAuthenticated:c,loginAccount:d}=await n(r);i?.onComplete?.({user:l,isNewUser:u,wasAlreadyAuthenticated:c,loginMethod:"passkey",loginAccount:d})}catch(r){throw l({status:"error",error:r}),i?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[n,o.status]),state:a}},exports.useLoginWithSiwe=i=>{let o=e.useCaptcha(),{siweState:s,setSiweState:n,client:a,generateSiweMessage:l,loginWithSiwe:u}=t.usePrivyInternal();return{generateSiweNonce:r.useCallback((async({address:r})=>{try{let i;if(o.enabled&&"error"===o.status)throw new e.CaptchaError(o.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);o.enabled&&"success"!==o.status&&(o.execute(),i=await o.waitForResult()),n({status:"generating-message"});let s=await a.generateSiweNonce({address:r,captchaToken:i});return n({status:"awaiting-signature"}),s}catch(r){throw n({status:"error",error:r}),i?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[a,o]),generateSiweMessage:r.useCallback((async({address:e,chainId:r})=>{try{return await l({address:e,chainId:r})}catch(e){throw n({status:"error",error:e}),i?.onError?.(e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}}),[l]),loginWithSiwe:r.useCallback((async({message:r,signature:s,disableSignup:a})=>{try{let n;if(o.enabled&&"error"===o.status)throw new e.CaptchaError(o.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);o.enabled&&"success"!==o.status&&(o.execute(),n=await o.waitForResult());let l=await u({message:r,signature:s,captchaToken:n,disableSignup:a});return i?.onComplete?.({user:l,isNewUser:!1,wasAlreadyAuthenticated:!1,loginMethod:"siwe",loginAccount:null}),l}catch(r){throw n({status:"error",error:r}),i?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[u,o.status]),state:s}},exports.useLoginWithSms=i=>{let o=e.useCaptcha(),{smsOtpState:s,setSmsOtpState:n,initLoginWithSms:a,loginWithCode:l}=t.usePrivyInternal();return{sendCode:r.useCallback((async({phoneNumber:r,disableSignup:s})=>{try{let i;if(!r)throw Error("SMS required to send OTP code");if(o.enabled&&"error"===o.status)throw new e.CaptchaError(o.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);return o.enabled&&"success"!==o.status&&(o.execute(),i=await o.waitForResult()),await a({phoneNumber:r,captchaToken:i,disableSignup:s,withPrivyUi:!1})}catch(r){throw n({status:"error",error:r}),i?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[a]),loginWithCode:r.useCallback((async({code:r})=>{try{if(o.enabled&&"success"!==o.status)throw new e.CaptchaError(o.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);let{user:s,isNewUser:n,wasAlreadyAuthenticated:a,linkedAccount:u}=await l(r);i?.onComplete?.({user:s,isNewUser:n,wasAlreadyAuthenticated:a,loginMethod:"sms",loginAccount:u})}catch(r){throw n({status:"error",error:r}),i?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[l,o.status]),state:s}},exports.useLoginWithTelegram=i=>{let o=e.useCaptcha(),{initLoginWithTelegram:s,loginWithTelegram:n,telegramAuthState:a,setTelegramAuthState:l}=t.usePrivyInternal();return{login:r.useCallback((async r=>{try{if(o.enabled&&"success"!==o.status)throw new e.CaptchaError(o.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);await s(o.token,r?.disableSignup);let{user:a,isNewUser:l,loginAccount:u,wasAlreadyAuthenticated:c}=await n({intent:"login"});i?.onComplete?.({user:a,isNewUser:l,wasAlreadyAuthenticated:c,loginMethod:"telegram",loginAccount:u})}catch(r){throw l({status:"error",error:r}),i?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[s,n,o]),state:a}},exports.useModalStatus=()=>{let{isModalOpen:t}=r.useContext(e.PrivyContext);return{isOpen:t}},exports.useOAuthTokens=function(r){let{authenticated:i,user:o}=e.usePrivyContext(),{initLoginWithOAuth:s}=t.usePrivyInternal(),n=e.useEmitPrivyEvent();return e.usePrivyEventSubscription("oAuthAuthorization",r),{reauthorize:e=>u(i,o,s,n,e.provider)}},exports.useRecoverEmbeddedWallet=()=>{let{user:i}=e.usePrivyContext(),{walletProxy:o}=t.usePrivyInternal();return{recover:r.useCallback((async r=>{if(!o)throw Error("Wallet proxy is not ready");let s=await e.getAccessToken();if(!i||!s)throw new t.PrivyClientError("User must be logged in before attempting to modify the recovery method.");let{entropyId:n,entropyIdVerifier:a}=e.getEntropyDetailsForUser(i);try{await o.recover({entropyId:n,entropyIdVerifier:a,accessToken:s,...r})}catch{throw new t.PrivyClientError("Unable to recover wallets")}}),[o,i])}},exports.useSendTransaction=function(t){let{sendTransaction:i}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("sendTransaction",t),{sendTransaction:i}},exports.useSessionSigners=()=>{let{addSessionSignersInternal:r,removeSessionSignersInternal:i}=(()=>{let{getAccessToken:r,user:i}=e.usePrivyContext(),o=t.usePrivyInternal(),{signWithUserSigner:s}=e.useSignWithUserSigner(),n=async({wallet:e,additional_signers:n})=>{let l=await r();if(!i||!l)throw new t.PrivyClientError("User must be authenticated and have an embedded wallet to delegate actions.");if(!e.id)throw new t.PrivyClientError("Wallet to add signers to must have ID on server");if(!o.walletProxy)throw new t.PrivyClientError("Wallet proxy not initialized.");await a.updateWallet(o.privy,{wallet_id:e.id},s,{additional_signers:n})};return{addSessionSignersInternal:async({address:s,signers:l})=>{let u=await r();if(!i||!u)throw new t.PrivyClientError("User must be authenticated and have an embedded wallet to add a session signer.");let c=o.walletProxy??await o.initializeWalletProxy(15e3);if(!c)throw new t.PrivyClientError("Wallet proxy not initialized.");let d=e.getPrivyWalletWithAddress(i,s);if(!d)throw new t.PrivyClientError("Address to add signers too is not associated with current user.");if(e.getIsUnifiedWallet(d)){if(0===l.length)throw new t.PrivyClientError("Must specify at least one signer to add.");let r=[...(await a.getWallet(o.privy,{wallet_id:d.id})).additional_signers,...e.parseAdditionalSigners(l)];await n({wallet:d,additional_signers:r})}else{if(d.delegated)return{user:i};if(l.length>0)throw new t.PrivyClientError("This embedded wallet does not support specifying signers. If signing is enabled in the dashboard, signer will default to that key. Otherwise, no signatures will be required for the wallet.");let r=e.getDelegatedWalletsData({address:s,user:i}),n=e.getRootWalletDataForDelegation({address:s,user:i});await o.recoverEmbeddedWallet({address:s}),await c.createDelegatedAction({accessToken:u,rootWallet:n,delegatedWallets:[r]})}let h=await o.refreshSessionAndUser();if(!h)throw Error("Could not refresh user");return{user:h}},removeSessionSignersInternal:async({address:s})=>{let a=await r();if(!i||!a)throw new t.PrivyClientError("User must be authenticated and have an embedded wallet to delegate actions.");if(!(o.walletProxy??await o.initializeWalletProxy(15e3)))throw new t.PrivyClientError("Wallet proxy not initialized.");let l=e.getPrivyWalletWithAddress(i,s);if(!l)throw new t.PrivyClientError("Address to remove signers from is not associated with current user.");e.getIsUnifiedWallet(l)?await n({wallet:l,additional_signers:[]}):await o.client.revokeDelegatedWallet();let u=await o.refreshSessionAndUser();if(!u)throw Error("Could not refresh user");return{user:u}}}})();return{addSessionSigners:async({address:e,signers:t})=>r({address:e,signers:t}),removeSessionSigners:async({address:e})=>i({address:e})}},exports.useSetWalletPassword=function(t){let{setWalletPassword:i}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("setWalletPassword",t),{setWalletPassword:i}},exports.useSetWalletRecovery=function(t){let{setWalletRecovery:i}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("setWalletRecovery",t),{setWalletRecovery:i}},exports.useSignAuthorization=()=>{let{ready:i,wallets:o}=e.useWallets(),{user:a}=e.usePrivyContext(),{rpcConfig:l,chains:u,appId:c}=t.usePrivyInternal();return{signAuthorization:r.useCallback((async(r,t)=>{if(!a)throw Error("User must be authenticated before signing with a Privy wallet");if(!i)throw Error("Wallets are not ready");let d=t?.address??e.getPrivyEthereumWallet(a)?.address??s.zeroAddress,h=o.find((e=>s.getAddress(e.address)===s.getAddress(d)));if(!h)throw Error("Signing wallet not found.");let y=r.chainId??Number(h.chainId.split(":")[1]),w=u.find((e=>e.id===y));if(!w)throw Error("Error, chain not configured in PrivyProvider config");let p=s.createWalletClient({account:d,chain:w,transport:s.http(e.getJsonRpcEndpointFromChain(w,l,c))}),g=await p.prepareAuthorization({...r}),C=await h.getEthereumProvider(),v=await C.request({method:"secp256k1_sign",params:[n.hashAuthorization(g)]});return{...g,...s.parseSignature(v)}}),[i,o,a,u])}},exports.useSignMessage=function(t){let{signMessage:i}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("signMessage",t),{signMessage:i}},exports.useSignTransaction=function(){let{signTransaction:t}=r.useContext(e.PrivyContext);return{signTransaction:t}},exports.useSignTypedData=function(t){let{signTypedData:i}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("signTypedData",t),{signTypedData:i}},exports.useSignupWithPasskey=i=>{let o=e.useCaptcha(),{initSignupWithPasskey:s,signupWithPasskey:n,passkeyAuthState:a,setPasskeyAuthState:l}=t.usePrivyInternal();return{signupWithPasskey:r.useCallback((async()=>{try{let r;if(o.enabled&&"error"===o.status)throw new e.CaptchaError(o.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);o.enabled&&"success"!==o.status&&(o.execute(),r=await o.waitForResult()),await s({captchaToken:r,withPrivyUi:!1});let{user:a,isNewUser:l,wasAlreadyAuthenticated:u,loginAccount:c}=await n();i?.onComplete?.({user:a,isNewUser:l,wasAlreadyAuthenticated:u,loginMethod:"passkey",loginAccount:c})}catch(e){throw l({status:"error",error:e}),i?.onError?.(e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}}),[n,o.status]),state:a}},exports.useSubscribeToJwtAuthWithFlag=function({isAuthenticated:t,isLoading:i,...o}){let s=r.useRef();r.useEffect((()=>{i||s.current?.()}),[t,i]);let n=r.useCallback((e=>(s.current=e,()=>{s.current=void 0})),[]);return e.useSyncJwtBasedAuthState({...o,subscribe:n})},exports.useToken=function(t){let{getAccessToken:i}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("accessToken",t),{getAccessToken:i}},exports.useUpdateAccount=function(t){let{updateEmail:i,updatePhone:o}=r.useContext(e.PrivyContext);return e.usePrivyEventSubscription("update",t),{updateEmail:i,updatePhone:o}},exports.useUser=()=>{let{setUser:i,client:o}=r.useContext(t.InternalPrivyContext),{user:s}=r.useContext(e.PrivyContext);return{user:s,refreshUser:r.useCallback((async()=>{let e=await(o?.updateUserAndIdToken());return i(e??null),e}),[o,i])}};
