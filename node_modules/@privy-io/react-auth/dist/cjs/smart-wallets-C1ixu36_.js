"use strict";var e=require("react"),t=require("viem"),r=require("./privy-provider-DFRGMmYo.js"),n=require("./internal-context-Bj24LJZ_.js"),a=require("./getEmbeddedConnectedWallet-DTU4T9TJ.js"),i=require("permissionless"),s=require("permissionless/accounts"),o=require("permissionless/clients/pimlico"),l=require("viem/account-abstraction"),c=require("@privy-io/js-sdk-core");let d={address:l.entryPoint06Address,version:"0.6"},u={address:l.entryPoint07Address,version:"0.7"},p=({owner:e,smartWalletType:t,publicClient:r})=>{switch(t){case c.SAFE:return s.toSafeSmartAccount({client:r,entryPoint:u,owners:[e],version:"1.4.1"});case c.KERNEL:return s.toEcdsaKernelSmartAccount({client:r,version:"0.3.1",entryPoint:u,owners:[e]});case c.BICONOMY:return s.toBiconomySmartAccount({client:r,owners:[e],entryPoint:d});case c.LIGHT_ACCOUNT:return s.toLightSmartAccount({client:r,entryPoint:d,owner:e,version:"1.1.0"});case c.COINBASE_SMART_WALLET:return async function({client:e,owner:t}){let[r]=await t.request({method:"eth_accounts"});if(!r)throw Error("Unable to request embedded owner for eth_accounts");return await l.toCoinbaseSmartAccount({client:e,owners:[{type:"local",source:"privy",address:r,sign:async({hash:e})=>await t.request({method:"secp256k1_sign",params:[e]})}]})}({client:r,owner:e});case c.THIRDWEB:return s.toThirdwebSmartAccount({client:r,entryPoint:u,owner:e});default:throw Error(`Invalid smart account type: ${t}.`)}};const y=({calls:e,chain:t,maxPriorityFeePerGas:r,maxFeePerGas:n,nonce:a})=>e.map((e=>({to:e.to||void 0,data:e.data,value:e.value,chainId:t.id,nonce:a,maxFeePerGas:n,maxPriorityFeePerGas:r}))),m=async({chain:e,paymasterContext:a,account:s,signer:l,user:c,smartWalletsConfig:d,rpcConfig:u,privyAppId:y})=>{if(!(d?.enabled&&c&&s&&l))return;let m=d?.configuredNetworks.find((t=>t.chainId===`eip155:${e.id}`));if(!m)throw new n.PrivyClientError(`The chain ${e.name} (eip155:${e.id}) must be configured in the smart wallet configuration in your dashboard`);let g=c.smartWallet?.smartWalletType??d.smartWalletType,h=r.getJsonRpcEndpointFromChain(e,u,y),P=t.createPublicClient({chain:e,transport:t.http(h)}),f=a??m.paymasterContext,w=await(async({owner:e,smartWalletType:r,chain:n,publicClient:a,bundlerUrl:s,paymasterUrl:l,paymasterContext:c})=>{let d=await p({owner:e,smartWalletType:r,publicClient:a}),u=o.createPimlicoClient({transport:t.http(s),entryPoint:d.entryPoint}),y=l?o.createPimlicoClient({transport:t.http(l),entryPoint:d.entryPoint}):void 0;return i.createSmartAccountClient({account:d,chain:n,paymaster:y,paymasterContext:c,bundlerTransport:t.http(s),userOperation:{estimateFeesPerGas:async()=>{if(["public.pimlico.io","api.pimlico.io"].some((e=>s.includes(e))))return await u.getUserOperationGasPrice().then((e=>e.fast));if(["rpc.zerodev.app"].some((e=>s.includes(e))))return(await u.request({method:"zd_getUserOperationGasPrice",params:[]})).fast;if(["g.alchemy.com"].some((e=>s.includes(e)))){let[e,t]=await Promise.all([a.getBlock({blockTag:"latest"}),u.request({method:"rundler_maxPriorityFeePerGas",params:[]})]);if(!e.baseFeePerGas||!t)throw Error("Failed to get block or maxPriorityFeePerGasEstimate");return{maxFeePerGas:150n*e.baseFeePerGas/100n+BigInt(t.toString()),maxPriorityFeePerGas:BigInt(t.toString())}}{let e=await a.estimateFeesPerGas(),t=s.includes("api.developer.coinbase.com")?175n:150n;return{...e,maxFeePerGas:e.maxFeePerGas*t/100n,maxPriorityFeePerGas:e.maxPriorityFeePerGas*t/100n}}}}})})({owner:l,smartWalletType:g,chain:e,publicClient:P,paymasterContext:f,...m});if(!w)throw new n.PrivyClientError(`Failed to create smart wallet client for chain ${e.name} (eip155:${e.id})`);return w};exports.callsToTransactionRequests=y,exports.getSmartWalletClient=m,exports.useSmartWalletsUIWrapper=()=>{let{hideWalletUIs:e,openPrivyModal:t,isHeadlessSigning:a}=n.usePrivyInternal(),{setModalData:i}=r.usePrivyModal(),{user:s}=r.usePrivyContext(),o=r.getPrivyEthereumWallet(s),l=!!o&&r.getIsUnifiedWallet(o);return{wrapSmartAccountClientWithUIs:n=>({...n,sendTransaction:async(c,d)=>{if(a({showWalletUIs:d?.uiOptions?.showWalletUIs}))return e.current=!0,await n.sendTransaction(c).finally((()=>e.current=!1));let u=[];"calls"in c&&void 0!==c.calls?u=[...c.calls]:"to"in c&&(u=[{to:c.to,value:c.value||BigInt(0),data:c.data||"0x"}]);let p=async()=>{if(!n.paymaster)return!1;let{paymasterAndData:e,paymasterData:t}=await n.prepareUserOperation({calls:u,maxFeePerGas:c.maxFeePerGas,maxPriorityFeePerGas:c.maxPriorityFeePerGas,nonce:c.nonce?BigInt(c.nonce):void 0});return Number(e??t??0)>0};return new Promise((async(a,m)=>{e.current=!0;let{entropyId:g,entropyIdVerifier:h}=r.getEntropyDetailsForUser(s);i({connectWallet:{recoveryMethod:o.recoveryMethod,connectingWalletAddress:o.address,isUnifiedWallet:l,entropyId:g,entropyIdVerifier:h,onCompleteNavigateTo:r.SendTransactionScreen,onFailure:()=>{}},sendTransaction:{transactionRequests:y({calls:u,chain:n.chain,maxPriorityFeePerGas:c.maxPriorityFeePerGas,maxFeePerGas:c.maxFeePerGas,nonce:c.nonce?BigInt(c.nonce):void 0}),transactingWalletIndex:0,transactingWalletAddress:n.account.address,entropyId:g,entropyIdVerifier:h,getIsSponsored:p,signOnly:!1,onConfirm:()=>n.sendTransaction(c),onSuccess:e=>a(e.hash),onFailure:m,uiOptions:d?.uiOptions??{}}}),t(r.EmbeddedWalletConnectingScreen)})).finally((()=>{e.current=!1}))},signMessage:async(c,d)=>a({showWalletUIs:d?.uiOptions?.showWalletUIs})?(e.current=!0,await n.signMessage(c).finally((()=>e.current=!1))):new Promise((async(a,u)=>{let{entropyId:p,entropyIdVerifier:y}=r.getEntropyDetailsForUser(s);e.current=!0,i({connectWallet:{recoveryMethod:o.recoveryMethod,connectingWalletAddress:o.address,isUnifiedWallet:l,entropyId:p,entropyIdVerifier:y,onCompleteNavigateTo:r.SignRequestScreen,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof c.message?c.message:c.message.raw.toString(),confirmAndSign:()=>n.signMessage(c),onSuccess:e=>a(e),onFailure:u,uiOptions:d?.uiOptions??{}}}),t(r.EmbeddedWalletConnectingScreen)})).finally((()=>{e.current=!1})),signTypedData:async(c,d)=>a({showWalletUIs:d?.uiOptions?.showWalletUIs})?(e.current=!0,await n.signTypedData(c).finally((()=>e.current=!1))):new Promise((async(a,u)=>{e.current=!0;let{entropyId:p,entropyIdVerifier:y}=r.getEntropyDetailsForUser(s);i({connectWallet:{recoveryMethod:o.recoveryMethod,connectingWalletAddress:o.address,isUnifiedWallet:l,entropyId:p,entropyIdVerifier:y,onCompleteNavigateTo:r.SignRequestScreen,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:c,confirmAndSign:()=>n.signTypedData(c),onSuccess:e=>a(e),onFailure:u,uiOptions:d?.uiOptions??{}}}),t(r.EmbeddedWalletConnectingScreen)})).finally((()=>{e.current=!1}))})}},exports.useSmartWalletsWrapper=({clientConfig:t,smartWalletsConfig:i})=>{let{hideWalletUIs:s,openPrivyModal:o,appId:l,isHeadlessSigning:c}=n.usePrivyInternal(),d=r.useAppConfig(),{setModalData:u}=r.usePrivyModal(),{user:p}=r.usePrivyContext(),{chains:g}=r.useAppConfig(),{chainId:h,clients:P,setChainId:f,chainIdState:w}=(()=>{let t=e.useRef(),[r,n]=e.useState();return{clients:e.useRef({}),setChainId:e=>{t.current=e,n(e)},chainId:t,chainIdState:r}})(),I=g.find((e=>e.id===w)),{wallets:v}=r.useWallets(),W=r.getPrivyEthereumWallet(p),C=a.getEmbeddedConnectedWallet(v),S=!!W&&r.getIsUnifiedWallet(W),F=e.useCallback((async()=>h.current),[h]),x=e.useCallback((async({id:e})=>{if(!P.current[e]){let r=await m({chain:g.find((t=>t.id===e)),account:W,signer:await(C?.getEthereumProvider()),user:p,paymasterContext:t?.paymasterContext,smartWalletsConfig:i,rpcConfig:d.rpcConfig,privyAppId:l});r&&(P.current[e]=r)}f(e)}),[g,t,v,p,i]);return{wrapSmartAccountClient:e=>{P.current[e.chain.id]=e,w||f(e.chain.id);return{...e,sendTransaction:async(e,t)=>{let a=P.current[h.current];if(!a)throw new n.PrivyClientError(`Smart wallet client for chain (eip155:${h.current}) not found`);if(delete e.account,c({showWalletUIs:t?.uiOptions?.showWalletUIs}))return s.current=!0,await a.sendTransaction(e).finally((()=>s.current=!1));let i=[];"calls"in e&&void 0!==e.calls?i=[...e.calls]:"to"in e&&(i=[{to:e.to,value:e.value||BigInt(0),data:e.data||"0x"}]);let l=async()=>{let{paymasterAndData:t,paymasterData:r,maxFeePerGas:n,maxPriorityFeePerGas:s}=await a.prepareUserOperation({calls:i,maxFeePerGas:e.maxFeePerGas,maxPriorityFeePerGas:e.maxPriorityFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0});return 0===Number(n)&&0===Number(s)||Number(t??r??0)>0};return new Promise((async(n,c)=>{s.current=!0;let{entropyId:d,entropyIdVerifier:m}=r.getEntropyDetailsForUser(p);u({connectWallet:{recoveryMethod:W.recoveryMethod,connectingWalletAddress:W.address,isUnifiedWallet:S,entropyId:d,entropyIdVerifier:m,onCompleteNavigateTo:r.SendTransactionScreen,onFailure:()=>{}},sendTransaction:{transactionRequests:y({calls:i,chain:a.chain,maxPriorityFeePerGas:e.maxPriorityFeePerGas,maxFeePerGas:e.maxFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0}),transactingWalletIndex:0,transactingWalletAddress:a.account.address,entropyId:d,entropyIdVerifier:m,getIsSponsored:l,signOnly:!1,onConfirm:()=>a.sendTransaction(e),onSuccess:e=>n(e.hash),onFailure:c,uiOptions:t?.uiOptions??{}}}),o(r.EmbeddedWalletConnectingScreen)})).finally((()=>{s.current=!1}))},signMessage:async(e,t)=>{let a=P.current[h.current];if(!a)throw new n.PrivyClientError(`Smart wallet client for chain (eip155:${h.current}) not found`);return c({showWalletUIs:t?.uiOptions?.showWalletUIs})?(s.current=!0,await a.signMessage(e).finally((()=>s.current=!1))):new Promise((async(n,i)=>{let{entropyId:l,entropyIdVerifier:c}=r.getEntropyDetailsForUser(p);s.current=!0,u({connectWallet:{recoveryMethod:W.recoveryMethod,connectingWalletAddress:W.address,isUnifiedWallet:S,entropyId:l,entropyIdVerifier:c,onCompleteNavigateTo:r.SignRequestScreen,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof e.message?e.message:e.message.raw.toString(),confirmAndSign:()=>a.signMessage(e),onSuccess:e=>n(e),onFailure:i,uiOptions:t?.uiOptions??{}}}),o(r.EmbeddedWalletConnectingScreen)})).finally((()=>{s.current=!1}))},signTypedData:async(e,t)=>{let a=P.current[h.current];if(!a)throw new n.PrivyClientError(`Smart wallet client for chain (eip155:${h.current}) not found`);return delete e.account,c({showWalletUIs:t?.uiOptions?.showWalletUIs})?(s.current=!0,await a.signTypedData(e).finally((()=>s.current=!1))):new Promise((async(n,i)=>{s.current=!0;let{entropyId:l,entropyIdVerifier:c}=r.getEntropyDetailsForUser(p);u({connectWallet:{recoveryMethod:W.recoveryMethod,connectingWalletAddress:W.address,isUnifiedWallet:S,entropyId:l,entropyIdVerifier:c,onCompleteNavigateTo:r.SignRequestScreen,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:e,confirmAndSign:()=>a.signTypedData(e),onSuccess:e=>n(e),onFailure:i,uiOptions:t?.uiOptions??{}}}),o(r.EmbeddedWalletConnectingScreen)})).finally((()=>{s.current=!1}))},getChainId:F,chain:I,switchChain:x}}}};
