import { SiweMessage, SiweResponse } from 'siwe';
export { generateNonce } from 'siwe';
import { Result } from 'neverthrow';
import { Hex } from 'viem';
import { Provider } from 'ethers';
export { Provider } from 'ethers';

interface AuthClientErrorOpts {
    message: string;
    cause: Error | AuthClientError;
    presentable: boolean;
}
declare class AuthClientError extends Error {
    readonly errCode: AuthClientErrorCode;
    readonly presentable: boolean;
    /**
     * @param errCode - the AuthClientError code for this message
     * @param context - a message, another Error, or a AuthClientErrorOpts
     */
    constructor(errCode: AuthClientErrorCode, context: Partial<AuthClientErrorOpts> | string | Error);
}
/**
 * AuthClientErrorCode defines all the types of errors that can be raised.
 *
 * A string union type is chosen over an enumeration since TS enums are unusual types that generate
 * javascript code and may cause downstream issues. See:
 * https://www.executeprogram.com/blog/typescript-features-to-avoid
 */
type AuthClientErrorCode = "unauthenticated" | "unauthorized" | "bad_request" | "bad_request.validation_failure" | "not_found" | "not_implemented" | "unavailable" | "unknown";
/** Type alias for shorthand when handling errors */
type AuthClientResult<T> = Result<T, AuthClientError>;
type AuthClientAsyncResult<T> = Promise<AuthClientResult<T>>;
type NoneOf<T> = {
    [K in keyof T]: never;
};
type Unwrapped<T> = (T & {
    isError: false;
    error?: never;
}) | (NoneOf<T> & {
    isError: true;
    error?: AuthClientError;
});
type AsyncUnwrapped<T> = Promise<Unwrapped<T>>;
declare const unwrap: <T>(result: AuthClientResult<T>) => Unwrapped<T>;

interface EthereumConnector {
    getFid: (custody: Hex) => Promise<BigInt>;
}

interface CreateClientArgs {
    relay?: string;
    version?: string;
    ethereum: EthereumConnector;
}
interface ClientConfig {
    relay: string;
    version?: string;
}
interface Client {
    config: ClientConfig;
    ethereum: EthereumConnector;
}
declare const createClient: ({ ethereum, ...config }: CreateClientArgs) => {
    config: {
        relay: string;
        version: string;
    };
    ethereum: EthereumConnector;
};

interface HttpOpts {
    authToken?: string;
    headers?: Record<string, string>;
}
interface PollOpts<ResponseDataType> {
    interval?: number;
    timeout?: number;
    successCode?: number;
    onResponse?: (response: HttpResponse<ResponseDataType>) => void;
}
interface HttpResponse<ResponseDataType> {
    response: Response;
    data: ResponseDataType;
}
type AsyncHttpResponse<T> = Promise<HttpResponse<T>>;
declare const get: <ResponseDataType>(client: Client, path: string, opts?: HttpOpts) => AuthClientAsyncResult<HttpResponse<ResponseDataType>>;
declare const post: <BodyType, ResponseDataType>(client: Client, path: string, json: BodyType, opts?: HttpOpts) => AuthClientAsyncResult<HttpResponse<ResponseDataType>>;
declare const poll: <ResponseDataType>(client: Client, path: string, pollOpts?: PollOpts<ResponseDataType> | undefined, opts?: HttpOpts) => AuthClientAsyncResult<HttpResponse<ResponseDataType>>;

type CreateChannelArgs = CreateChannelRequest;
type CreateChannelResponse = AsyncUnwrapped<HttpResponse<CreateChannelAPIResponse>>;
interface CreateChannelRequest {
    siweUri: string;
    domain: string;
    nonce?: string;
    notBefore?: string;
    expirationTime?: string;
    requestId?: string;
    redirectUrl?: string;
}
interface CreateChannelAPIResponse {
    channelToken: string;
    url: string;
    nonce: string;
}
declare const createChannel: (client: Client, { ...request }: CreateChannelArgs) => CreateChannelResponse;

interface StatusArgs {
    channelToken: string;
}
type StatusResponse = AsyncUnwrapped<HttpResponse<StatusAPIResponse>>;
interface StatusAPIResponse {
    state: "pending" | "completed";
    nonce: string;
    url: string;
    message?: string;
    signature?: `0x${string}`;
    fid?: number;
    username?: string;
    bio?: string;
    displayName?: string;
    pfpUrl?: string;
    verifications?: string[];
    custody?: Hex;
    signatureParams: {
        siweUri: string;
        domain: string;
        nonce?: string;
        notBefore?: string;
        expirationTime?: string;
        requestId?: string;
        redirectUrl?: string;
    };
    metadata: {
        ip: string;
        userAgent: string;
    };
}
declare const status: (client: Client, { channelToken }: StatusArgs) => StatusResponse;

type FarcasterResourceParams = {
    fid: number;
};
type SignInMessageParams = Partial<SiweMessage> & FarcasterResourceParams;
interface BuildResponse {
    siweMessage: SiweMessage;
    message: string;
}

type VerifyResponse = Omit<SiweResponse, "error"> & FarcasterResourceParams;

interface VerifySignInMessageArgs {
    nonce: string;
    domain: string;
    message: string | Partial<SiweMessage>;
    signature: `0x${string}`;
}
type VerifySignInMessageResponse = Promise<Unwrapped<VerifyResponse>>;
declare const verifySignInMessage: (client: Client, { nonce, domain, message, signature }: VerifySignInMessageArgs, provider?: Provider) => VerifySignInMessageResponse;

interface WatchStatusArgs {
    channelToken: string;
    timeout?: number;
    interval?: number;
    onResponse?: (response: HttpResponse<StatusAPIResponse>) => void;
}
type WatchStatusResponse = AsyncUnwrapped<HttpResponse<StatusAPIResponse>>;
declare const watchStatus: (client: Client, args: WatchStatusArgs) => WatchStatusResponse;

interface AuthenticateArgs extends AuthenticateRequest {
    authKey: string;
    channelToken: string;
}
type AuthenticateResponse = AsyncUnwrapped<HttpResponse<AuthenticateAPIResponse>>;
interface AuthenticateRequest {
    message: string;
    signature: `0x${string}`;
    fid: number;
    username?: string;
    bio?: string;
    displayName?: string;
    pfpUrl?: string;
}
type AuthenticateAPIResponse = StatusAPIResponse;
declare const authenticate: (client: Client, { channelToken, authKey, ...request }: AuthenticateArgs) => AuthenticateResponse;

type BuildSignInMessageArgs = SignInMessageParams;
type BuildSignInMessageResponse = Unwrapped<BuildResponse>;
declare const buildSignInMessage: (_client: Client, args: BuildSignInMessageArgs) => BuildSignInMessageResponse;

interface ParsedSignInURI {
    channelToken: string;
}

interface ParseSignInURIArgs {
    uri: string;
}
type ParseSignInURIResponse = Unwrapped<ParsedSignInURI>;
declare const parseSignInURI: (_client: Client, { uri }: ParseSignInURIArgs) => ParseSignInURIResponse;

interface AppClient extends Client {
    createChannel: (args: CreateChannelArgs) => CreateChannelResponse;
    status: (args: StatusArgs) => StatusResponse;
    watchStatus: (args: WatchStatusArgs) => WatchStatusResponse;
    verifySignInMessage: (args: VerifySignInMessageArgs) => VerifySignInMessageResponse;
}
declare const createAppClient: (config: CreateClientArgs, provider?: Provider) => AppClient;

interface WalletClient extends Client {
    authenticate: (args: AuthenticateArgs) => AuthenticateResponse;
    buildSignInMessage: (args: BuildSignInMessageArgs) => BuildSignInMessageResponse;
    parseSignInURI: (args: ParseSignInURIArgs) => ParseSignInURIResponse;
}
declare const createWalletClient: (config: CreateClientArgs) => WalletClient;

interface ViemConfigArgs {
    rpcUrl?: string;
}
declare const viemConnector: (args?: ViemConfigArgs) => EthereumConnector;

export { type AppClient, type AsyncHttpResponse, type AsyncUnwrapped, type AuthClientAsyncResult, AuthClientError, type AuthClientErrorCode, type AuthClientResult, type AuthenticateAPIResponse, type AuthenticateArgs, type AuthenticateResponse, type BuildSignInMessageArgs, type BuildSignInMessageResponse, type Client, type ClientConfig, type CreateChannelAPIResponse, type CreateChannelArgs, type CreateChannelResponse, type CreateClientArgs, type HttpOpts, type HttpResponse, type NoneOf, type ParseSignInURIArgs, type ParseSignInURIResponse, type PollOpts, type StatusAPIResponse, type StatusArgs, type StatusResponse, type Unwrapped, type VerifySignInMessageArgs, type VerifySignInMessageResponse, type WalletClient, type WatchStatusArgs, type WatchStatusResponse, authenticate, buildSignInMessage, createAppClient, createChannel, createClient, createWalletClient, get, parseSignInURI, poll, post, status, unwrap, verifySignInMessage, viemConnector, watchStatus };
