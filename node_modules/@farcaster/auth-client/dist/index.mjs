var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
import { generateNonce } from "siwe";

// src/errors.ts
var AuthClientError = class extends Error {
  /**
   * @param errCode - the AuthClientError code for this message
   * @param context - a message, another Error, or a AuthClientErrorOpts
   */
  constructor(errCode, context) {
    let parsedContext;
    if (typeof context === "string") {
      parsedContext = { message: context };
    } else if (context instanceof Error) {
      parsedContext = { cause: context, message: context.message };
    } else {
      parsedContext = context;
    }
    if (!parsedContext.message) {
      parsedContext.message = parsedContext.cause?.message || "";
    }
    super(parsedContext.message, { cause: parsedContext.cause });
    __publicField(this, "errCode");
    /* Indicates if error message can be presented to the user */
    __publicField(this, "presentable", false);
    this.name = "AuthClientError";
    this.errCode = errCode;
  }
};
var unwrap = (result) => {
  if (result.isErr()) {
    return { error: result.error, isError: true };
  } else {
    return { ...result.value, isError: false };
  }
};

// src/clients/transports/http.ts
import { ResultAsync, ok, err } from "neverthrow";
var defaultPollOpts = {
  interval: 1e3,
  timeout: 1e4,
  successCode: 200,
  onResponse: () => {
  }
};
var get = async (client, path5, opts) => {
  return ResultAsync.fromPromise(
    fetch(getURI(client, path5), {
      headers: getHeaders(opts)
    }),
    (e) => {
      return new AuthClientError("unknown", e);
    }
  ).andThen((response) => {
    return ResultAsync.fromPromise(response.json(), (e) => {
      return new AuthClientError("unknown", e);
    }).andThen((data) => {
      return ok({ response, data });
    });
  });
};
var post = async (client, path5, json, opts) => {
  return ResultAsync.fromPromise(
    fetch(getURI(client, path5), {
      method: "POST",
      body: JSON.stringify(json),
      headers: getHeaders(opts)
    }),
    (e) => {
      return new AuthClientError("unknown", e);
    }
  ).andThen((response) => {
    return ResultAsync.fromPromise(response.json(), (e) => {
      return new AuthClientError("unknown", e);
    }).andThen((data) => {
      return ok({ response, data });
    });
  });
};
var poll = async (client, path5, pollOpts, opts) => {
  const { timeout, interval, successCode, onResponse } = {
    ...defaultPollOpts,
    ...pollOpts
  };
  const deadline = Date.now() + timeout;
  while (Date.now() < deadline) {
    const res = await get(client, path5, opts);
    if (res.isOk()) {
      const { response } = res.value;
      onResponse(res.value);
      if (response.status === successCode) {
        return ok(res.value);
      }
      await new Promise((resolve) => setTimeout(resolve, interval));
    } else {
      return err(res.error);
    }
  }
  return err(new AuthClientError("unavailable", `Polling timed out after ${timeout}ms`));
};
var getURI = (client, path5) => {
  return `${client.config.relay}/${client.config.version}/${path5}`;
};
var getHeaders = (opts) => {
  const headers = {
    ...opts?.headers
  };
  if (opts?.authToken) {
    headers["Authorization"] = `Bearer ${opts.authToken}`;
  }
  return { ...headers, "Content-Type": "application/json" };
};

// src/actions/app/createChannel.ts
var path = "channel";
var createChannel = async (client, { ...request }) => {
  const response = await post(client, path, request);
  return unwrap(response);
};

// src/actions/app/status.ts
var path2 = "channel/status";
var status = async (client, { channelToken }) => {
  const response = await get(client, path2, {
    authToken: channelToken
  });
  return unwrap(response);
};

// src/messages/verify.ts
import { SiweError } from "siwe";
import { ResultAsync as ResultAsync2, err as err3, ok as ok3 } from "neverthrow";

// src/messages/validate.ts
import { SiweMessage } from "siwe";
import { Result, err as err2, ok as ok2 } from "neverthrow";

// src/messages/constants.ts
var STATEMENT = "Farcaster Auth";
var CHAIN_ID = 10;

// src/messages/validate.ts
var FID_URI_REGEX = /^farcaster:\/\/fid\/([1-9]\d*)\/?$/;
var validate = (params) => {
  return Result.fromThrowable(
    // SiweMessage validates itself when constructed
    () => new SiweMessage(params),
    // If construction time validation fails, propagate the error
    (e) => new AuthClientError("bad_request.validation_failure", e)
  )().andThen(validateStatement).andThen(validateChainId).andThen(validateResources);
};
var parseResources = (message) => {
  const fid = parseFid(message);
  if (fid.isErr())
    return err2(fid.error);
  return ok2({ fid: fid.value });
};
var parseFid = (message) => {
  const resource = (message.resources ?? []).find((resource2) => {
    return FID_URI_REGEX.test(resource2);
  });
  if (!resource) {
    return err2(new AuthClientError("bad_request.validation_failure", "No fid resource provided"));
  }
  const fid = parseInt(resource.match(FID_URI_REGEX)?.[1] ?? "");
  if (isNaN(fid)) {
    return err2(new AuthClientError("bad_request.validation_failure", "Invalid fid"));
  }
  return ok2(fid);
};
var validateStatement = (message) => {
  const validStatement = message.statement === STATEMENT || message.statement === "Farcaster Connect";
  if (!validStatement) {
    return err2(new AuthClientError("bad_request.validation_failure", `Statement must be '${STATEMENT}'`));
  }
  return ok2(message);
};
var validateChainId = (message) => {
  if (message.chainId !== CHAIN_ID) {
    return err2(new AuthClientError("bad_request.validation_failure", `Chain ID must be ${CHAIN_ID}`));
  }
  return ok2(message);
};
var validateResources = (message) => {
  const fidResources = (message.resources ?? []).filter((resource) => {
    return FID_URI_REGEX.test(resource);
  });
  if (fidResources.length === 0) {
    return err2(new AuthClientError("bad_request.validation_failure", "No fid resource provided"));
  } else if (fidResources.length > 1) {
    return err2(new AuthClientError("bad_request.validation_failure", "Multiple fid resources provided"));
  } else {
    return ok2(message);
  }
};

// src/messages/verify.ts
var voidVerifyFid = (_custody) => Promise.reject(new Error("Not implemented: Must provide an fid verifier"));
var verify = async (nonce, domain, message, signature, options = {
  getFid: voidVerifyFid
}) => {
  const { getFid, provider } = options;
  const valid = validate(message).andThen((message2) => validateNonce(message2, nonce)).andThen((message2) => validateDomain(message2, domain));
  if (valid.isErr())
    return err3(valid.error);
  const siwe = (await verifySiweMessage(valid.value, signature, provider)).andThen(mergeResources);
  if (siwe.isErr())
    return err3(siwe.error);
  if (!siwe.value.success) {
    const errMessage = siwe.value.error?.type ?? "Failed to verify SIWE message";
    return err3(new AuthClientError("unauthorized", errMessage));
  }
  const fid = await verifyFidOwner(siwe.value, getFid);
  if (fid.isErr())
    return err3(fid.error);
  if (!fid.value.success) {
    const errMessage = siwe.value.error?.type ?? "Failed to validate fid owner";
    return err3(new AuthClientError("unauthorized", errMessage));
  }
  const { error, ...response } = fid.value;
  return ok3(response);
};
var validateNonce = (message, nonce) => {
  if (message.nonce !== nonce) {
    return err3(new AuthClientError("unauthorized", "Invalid nonce"));
  } else {
    return ok3(message);
  }
};
var validateDomain = (message, domain) => {
  if (message.domain !== domain) {
    return err3(new AuthClientError("unauthorized", "Invalid domain"));
  } else {
    return ok3(message);
  }
};
var verifySiweMessage = async (message, signature, provider) => {
  return ResultAsync2.fromPromise(message.verify({ signature }, { provider, suppressExceptions: true }), (e) => {
    return new AuthClientError("unauthorized", e);
  });
};
var verifyFidOwner = async (response, fidVerifier) => {
  const signer = response.data.address;
  return ResultAsync2.fromPromise(fidVerifier(signer), (e) => {
    return new AuthClientError("unavailable", e);
  }).andThen((fid) => {
    if (fid !== BigInt(response.fid)) {
      response.success = false;
      response.error = new SiweError(
        `Invalid resource: signer ${signer} does not own fid ${response.fid}.`,
        response.fid.toString(),
        fid.toString()
      );
    }
    return ok3(response);
  });
};
var mergeResources = (response) => {
  return parseResources(response.data).andThen((resources) => {
    return ok3({ ...resources, ...response });
  });
};

// src/actions/app/verifySignInMessage.ts
var verifySignInMessage = async (client, { nonce, domain, message, signature }, provider) => {
  const result = await verify(nonce, domain, message, signature, {
    getFid: client.ethereum.getFid,
    provider
  });
  return unwrap(result);
};

// src/actions/app/watchStatus.ts
var path3 = "channel/status";
var voidCallback = () => {
};
var watchStatus = async (client, args) => {
  const result = await poll(
    client,
    path3,
    {
      timeout: args?.timeout ?? 3e5,
      interval: args?.interval ?? 1e3,
      onResponse: args?.onResponse ?? voidCallback
    },
    { authToken: args.channelToken }
  );
  return unwrap(result);
};

// src/actions/auth/authenticate.ts
var path4 = "channel/authenticate";
var authenticate = async (client, { channelToken, authKey, ...request }) => {
  const result = await post(client, path4, request, {
    authToken: channelToken,
    headers: {
      "X-Farcaster-Auth-Relay-Key": authKey
    }
  });
  return unwrap(result);
};

// src/messages/build.ts
import { err as err4, ok as ok4 } from "neverthrow";
var build = (params) => {
  const { fid, ...siweParams } = params;
  const resources = siweParams.resources ?? [];
  siweParams.version = "1";
  siweParams.statement = STATEMENT;
  siweParams.chainId = CHAIN_ID;
  siweParams.resources = [buildFidResource(fid), ...resources];
  const valid = validate(siweParams);
  if (valid.isErr())
    return err4(valid.error);
  else {
    const siweMessage = valid.value;
    return ok4({ siweMessage, message: siweMessage.toMessage() });
  }
};
var buildFidResource = (fid) => {
  return `farcaster://fid/${fid}`;
};

// src/actions/auth/buildSignInMessage.ts
var buildSignInMessage = (_client, args) => {
  return unwrap(build(args));
};

// src/messages/parseSignInURI.ts
import { err as err5, ok as ok5 } from "neverthrow";
var parseSignInURI = (signInUri) => {
  const url = new URL(signInUri);
  const searchParams = Object.fromEntries(url.searchParams.entries());
  const { channelToken } = searchParams;
  if (!channelToken) {
    return err5(validationFail("No channel token provided"));
  }
  return ok5({ channelToken });
};
var validationFail = (message) => {
  return new AuthClientError("bad_request.validation_failure", message);
};

// src/actions/auth/parseSignInURI.ts
var parseSignInURI2 = (_client, { uri }) => {
  return unwrap(parseSignInURI(uri));
};

// src/clients/createClient.ts
var configDefaults = {
  relay: "https://relay.farcaster.xyz",
  version: "v1"
};
var createClient = ({ ethereum, ...config }) => {
  return {
    config: { ...configDefaults, ...config },
    ethereum
  };
};

// src/clients/createAppClient.ts
var createAppClient = (config, provider) => {
  const client = createClient(config);
  return {
    ...client,
    createChannel: (args) => createChannel(client, args),
    status: (args) => status(client, args),
    watchStatus: (args) => watchStatus(client, args),
    verifySignInMessage: (args) => verifySignInMessage(client, args, provider)
  };
};

// src/clients/createWalletClient.ts
var createWalletClient = (config) => {
  const client = createClient(config);
  return {
    ...client,
    authenticate: (args) => authenticate(client, args),
    buildSignInMessage: (args) => buildSignInMessage(client, args),
    parseSignInURI: (args) => parseSignInURI2(client, args)
  };
};

// src/clients/ethereum/viemConnector.ts
import { createPublicClient, http } from "viem";
import { optimism } from "viem/chains";

// src/contracts/idRegistry.ts
var idRegistryABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_migrator",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOwner",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "AlreadyMigrated",
    type: "error"
  },
  {
    inputs: [],
    name: "GatewayFrozen",
    type: "error"
  },
  {
    inputs: [],
    name: "HasId",
    type: "error"
  },
  {
    inputs: [],
    name: "HasNoId",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "currentNonce",
        type: "uint256"
      }
    ],
    name: "InvalidAccountNonce",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidSignature",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyGuardian",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyMigrator",
    type: "error"
  },
  {
    inputs: [],
    name: "PermissionRevoked",
    type: "error"
  },
  {
    inputs: [],
    name: "SignatureExpired",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Add",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    name: "AdminReset",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "ChangeRecoveryAddress",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "idGateway",
        type: "address"
      }
    ],
    name: "FreezeIdGateway",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "migratedAt",
        type: "uint256"
      }
    ],
    name: "Migrated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "Recover",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "Register",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Remove",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldCounter",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newCounter",
        type: "uint256"
      }
    ],
    name: "SetIdCounter",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldIdGateway",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newIdGateway",
        type: "address"
      }
    ],
    name: "SetIdGateway",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldMigrator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newMigrator",
        type: "address"
      }
    ],
    name: "SetMigrator",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    inputs: [],
    name: "CHANGE_RECOVERY_ADDRESS_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "TRANSFER_AND_CHANGE_RECOVERY_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "TRANSFER_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "addGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint24",
            name: "fid",
            type: "uint24"
          },
          {
            internalType: "address",
            name: "custody",
            type: "address"
          },
          {
            internalType: "address",
            name: "recovery",
            type: "address"
          }
        ],
        internalType: "struct IIdRegistry.BulkRegisterData[]",
        name: "ids",
        type: "tuple[]"
      }
    ],
    name: "bulkRegisterIds",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint24",
            name: "fid",
            type: "uint24"
          },
          {
            internalType: "address",
            name: "custody",
            type: "address"
          }
        ],
        internalType: "struct IIdRegistry.BulkRegisterDefaultRecoveryData[]",
        name: "ids",
        type: "tuple[]"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "bulkRegisterIdsWithDefaultRecovery",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint24[]",
        name: "ids",
        type: "uint24[]"
      }
    ],
    name: "bulkResetIds",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "changeRecoveryAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "changeRecoveryAddressFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    name: "custodyOf",
    outputs: [
      {
        internalType: "address",
        name: "custody",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "domainSeparatorV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "freezeIdGateway",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "gatewayFrozen",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "gracePeriod",
    outputs: [
      {
        internalType: "uint24",
        name: "",
        type: "uint24"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "guardians",
    outputs: [
      {
        internalType: "bool",
        name: "isGuardian",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "structHash",
        type: "bytes32"
      }
    ],
    name: "hashTypedDataV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "idCounter",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "idGateway",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "idOf",
    outputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "isMigrated",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "migrate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "migratedAt",
    outputs: [
      {
        internalType: "uint40",
        name: "",
        type: "uint40"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "migrator",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "recover",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "recoveryDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "recoverySig",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "toDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "toSig",
        type: "bytes"
      }
    ],
    name: "recoverFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    name: "recoveryOf",
    outputs: [
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "register",
    outputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "removeGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_counter",
        type: "uint256"
      }
    ],
    name: "setIdCounter",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_idGateway",
        type: "address"
      }
    ],
    name: "setIdGateway",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_migrator",
        type: "address"
      }
    ],
    name: "setMigrator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "transfer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "transferAndChangeRecovery",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "fromDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "fromSig",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "toDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "toSig",
        type: "bytes"
      }
    ],
    name: "transferAndChangeRecoveryFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "fromDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "fromSig",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "toDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "toSig",
        type: "bytes"
      }
    ],
    name: "transferFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "useNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "custodyAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "digest",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "verifyFidSignature",
    outputs: [
      {
        internalType: "bool",
        name: "isValid",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var ID_REGISTRY_ADDRESS = "0x00000000Fc6c5F01Fc30151999387Bb99A9f489b";

// src/clients/ethereum/viemConnector.ts
var viemConnector = (args) => {
  const publicClient = createPublicClient({
    chain: optimism,
    transport: http(args?.rpcUrl)
  });
  const getFid = async (custody) => {
    return publicClient.readContract({
      address: ID_REGISTRY_ADDRESS,
      abi: idRegistryABI,
      functionName: "idOf",
      args: [custody]
    });
  };
  return {
    getFid
  };
};
export {
  AuthClientError,
  authenticate,
  buildSignInMessage,
  createAppClient,
  createChannel,
  createClient,
  createWalletClient,
  generateNonce,
  get,
  parseSignInURI2 as parseSignInURI,
  poll,
  post,
  status,
  unwrap,
  verifySignInMessage,
  viemConnector,
  watchStatus
};
